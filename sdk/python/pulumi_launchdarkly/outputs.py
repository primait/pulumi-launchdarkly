# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccessTokenInlineRole',
    'AccessTokenPolicyStatement',
    'AuditLogSubscriptionStatement',
    'CustomRolePolicy',
    'CustomRolePolicyStatement',
    'EnvironmentApprovalSetting',
    'FeatureFlagClientSideAvailability',
    'FeatureFlagCustomProperty',
    'FeatureFlagDefaults',
    'FeatureFlagEnvironmentContextTarget',
    'FeatureFlagEnvironmentFallthrough',
    'FeatureFlagEnvironmentPrerequisite',
    'FeatureFlagEnvironmentRule',
    'FeatureFlagEnvironmentRuleClause',
    'FeatureFlagEnvironmentTarget',
    'FeatureFlagVariation',
    'FlagTriggerInstructions',
    'MetricUrl',
    'ProjectDefaultClientSideAvailability',
    'ProjectEnvironment',
    'ProjectEnvironmentApprovalSetting',
    'RelayProxyConfigurationPolicy',
    'SegmentExcludedContext',
    'SegmentIncludedContext',
    'SegmentRule',
    'SegmentRuleClause',
    'TeamMemberRoleAttribute',
    'TeamRoleAttribute',
    'WebhookStatement',
    'GetAuditLogSubscriptionStatementResult',
    'GetEnvironmentApprovalSettingResult',
    'GetFeatureFlagClientSideAvailabilityResult',
    'GetFeatureFlagCustomPropertyResult',
    'GetFeatureFlagDefaultResult',
    'GetFeatureFlagEnvironmentContextTargetResult',
    'GetFeatureFlagEnvironmentFallthroughResult',
    'GetFeatureFlagEnvironmentPrerequisiteResult',
    'GetFeatureFlagEnvironmentRuleResult',
    'GetFeatureFlagEnvironmentRuleClauseResult',
    'GetFeatureFlagEnvironmentTargetResult',
    'GetFeatureFlagVariationResult',
    'GetFlagTriggerInstructionResult',
    'GetMetricUrlResult',
    'GetProjectClientSideAvailabilityResult',
    'GetProjectDefaultClientSideAvailabilityResult',
    'GetRelayProxyConfigurationPolicyResult',
    'GetSegmentExcludedContextResult',
    'GetSegmentIncludedContextResult',
    'GetSegmentRuleResult',
    'GetSegmentRuleClauseResult',
    'GetTeamMaintainerResult',
    'GetTeamMemberRoleAttributeResult',
    'GetTeamMembersTeamMemberResult',
    'GetTeamMembersTeamMemberRoleAttributeResult',
    'GetTeamRoleAttributeResult',
    'GetWebhookStatementResult',
]

@pulumi.output_type
class AccessTokenInlineRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessTokenInlineRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessTokenInlineRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessTokenInlineRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class AccessTokenPolicyStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessTokenPolicyStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessTokenPolicyStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessTokenPolicyStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class AuditLogSubscriptionStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditLogSubscriptionStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditLogSubscriptionStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditLogSubscriptionStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomRolePolicy(dict):
    def __init__(__self__, *,
                 actions: Sequence[_builtins.str],
                 effect: _builtins.str,
                 resources: Sequence[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomRolePolicyStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRolePolicyStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRolePolicyStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRolePolicyStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class EnvironmentApprovalSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoApplyApprovedChanges":
            suggest = "auto_apply_approved_changes"
        elif key == "canApplyDeclinedChanges":
            suggest = "can_apply_declined_changes"
        elif key == "canReviewOwnRequest":
            suggest = "can_review_own_request"
        elif key == "minNumApprovals":
            suggest = "min_num_approvals"
        elif key == "requiredApprovalTags":
            suggest = "required_approval_tags"
        elif key == "serviceConfig":
            suggest = "service_config"
        elif key == "serviceKind":
            suggest = "service_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentApprovalSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentApprovalSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentApprovalSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_apply_approved_changes: Optional[_builtins.bool] = None,
                 can_apply_declined_changes: Optional[_builtins.bool] = None,
                 can_review_own_request: Optional[_builtins.bool] = None,
                 min_num_approvals: Optional[_builtins.int] = None,
                 required: Optional[_builtins.bool] = None,
                 required_approval_tags: Optional[Sequence[_builtins.str]] = None,
                 service_config: Optional[Mapping[str, _builtins.str]] = None,
                 service_kind: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_apply_approved_changes: Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        :param _builtins.bool can_apply_declined_changes: Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        :param _builtins.bool can_review_own_request: Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        :param _builtins.int min_num_approvals: The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        :param _builtins.bool required: Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        :param Sequence[_builtins.str] required_approval_tags: An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        :param Mapping[str, _builtins.str] service_config: The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:
               
               	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
               	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        :param _builtins.str service_kind: The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        if auto_apply_approved_changes is not None:
            pulumi.set(__self__, "auto_apply_approved_changes", auto_apply_approved_changes)
        if can_apply_declined_changes is not None:
            pulumi.set(__self__, "can_apply_declined_changes", can_apply_declined_changes)
        if can_review_own_request is not None:
            pulumi.set(__self__, "can_review_own_request", can_review_own_request)
        if min_num_approvals is not None:
            pulumi.set(__self__, "min_num_approvals", min_num_approvals)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if required_approval_tags is not None:
            pulumi.set(__self__, "required_approval_tags", required_approval_tags)
        if service_config is not None:
            pulumi.set(__self__, "service_config", service_config)
        if service_kind is not None:
            pulumi.set(__self__, "service_kind", service_kind)

    @_builtins.property
    @pulumi.getter(name="autoApplyApprovedChanges")
    def auto_apply_approved_changes(self) -> Optional[_builtins.bool]:
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        return pulumi.get(self, "auto_apply_approved_changes")

    @_builtins.property
    @pulumi.getter(name="canApplyDeclinedChanges")
    def can_apply_declined_changes(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        return pulumi.get(self, "can_apply_declined_changes")

    @_builtins.property
    @pulumi.getter(name="canReviewOwnRequest")
    def can_review_own_request(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        return pulumi.get(self, "can_review_own_request")

    @_builtins.property
    @pulumi.getter(name="minNumApprovals")
    def min_num_approvals(self) -> Optional[_builtins.int]:
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        return pulumi.get(self, "min_num_approvals")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="requiredApprovalTags")
    def required_approval_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        return pulumi.get(self, "required_approval_tags")

    @_builtins.property
    @pulumi.getter(name="serviceConfig")
    def service_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        return pulumi.get(self, "service_config")

    @_builtins.property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> Optional[_builtins.str]:
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        return pulumi.get(self, "service_kind")


@pulumi.output_type
class FeatureFlagClientSideAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usingEnvironmentId":
            suggest = "using_environment_id"
        elif key == "usingMobileKey":
            suggest = "using_mobile_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagClientSideAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagClientSideAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagClientSideAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 using_environment_id: Optional[_builtins.bool] = None,
                 using_mobile_key: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool using_environment_id: Whether this flag is available to SDKs using the client-side ID.
        :param _builtins.bool using_mobile_key: Whether this flag is available to SDKs using a mobile key.
        """
        if using_environment_id is not None:
            pulumi.set(__self__, "using_environment_id", using_environment_id)
        if using_mobile_key is not None:
            pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> Optional[_builtins.bool]:
        """
        Whether this flag is available to SDKs using the client-side ID.
        """
        return pulumi.get(self, "using_environment_id")

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> Optional[_builtins.bool]:
        """
        Whether this flag is available to SDKs using a mobile key.
        """
        return pulumi.get(self, "using_mobile_key")


@pulumi.output_type
class FeatureFlagCustomProperty(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The unique custom property key.
        :param _builtins.str name: The name of the custom property.
        :param Sequence[_builtins.str] values: The list of custom property value strings.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The unique custom property key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the custom property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of custom property value strings.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class FeatureFlagDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offVariation":
            suggest = "off_variation"
        elif key == "onVariation":
            suggest = "on_variation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 off_variation: _builtins.int,
                 on_variation: _builtins.int):
        """
        :param _builtins.int off_variation: The index of the variation the flag will default to in all new environments when off.
        :param _builtins.int on_variation: The index of the variation the flag will default to in all new environments when on.
        """
        pulumi.set(__self__, "off_variation", off_variation)
        pulumi.set(__self__, "on_variation", on_variation)

    @_builtins.property
    @pulumi.getter(name="offVariation")
    def off_variation(self) -> _builtins.int:
        """
        The index of the variation the flag will default to in all new environments when off.
        """
        return pulumi.get(self, "off_variation")

    @_builtins.property
    @pulumi.getter(name="onVariation")
    def on_variation(self) -> _builtins.int:
        """
        The index of the variation the flag will default to in all new environments when on.
        """
        return pulumi.get(self, "on_variation")


@pulumi.output_type
class FeatureFlagEnvironmentContextTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextKind":
            suggest = "context_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironmentContextTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironmentContextTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironmentContextTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str],
                 variation: _builtins.int):
        """
        :param _builtins.str context_kind: The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        :param Sequence[_builtins.str] values: List of `user` strings to target.
        :param _builtins.int variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagEnvironmentFallthrough(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketBy":
            suggest = "bucket_by"
        elif key == "contextKind":
            suggest = "context_kind"
        elif key == "rolloutWeights":
            suggest = "rollout_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironmentFallthrough. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironmentFallthrough.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironmentFallthrough.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_by: Optional[_builtins.str] = None,
                 context_kind: Optional[_builtins.str] = None,
                 rollout_weights: Optional[Sequence[_builtins.int]] = None,
                 variation: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        :param _builtins.str context_kind: The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        :param Sequence[_builtins.int] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        :param _builtins.int variation: The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[_builtins.str]:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> Optional[_builtins.int]:
        """
        The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagEnvironmentPrerequisite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flagKey":
            suggest = "flag_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironmentPrerequisite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironmentPrerequisite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironmentPrerequisite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flag_key: _builtins.str,
                 variation: _builtins.int):
        """
        :param _builtins.str flag_key: The prerequisite feature flag's `key`.
        :param _builtins.int variation: The index of the prerequisite feature flag's variation to target.
        """
        pulumi.set(__self__, "flag_key", flag_key)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="flagKey")
    def flag_key(self) -> _builtins.str:
        """
        The prerequisite feature flag's `key`.
        """
        return pulumi.get(self, "flag_key")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the prerequisite feature flag's variation to target.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagEnvironmentRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketBy":
            suggest = "bucket_by"
        elif key == "contextKind":
            suggest = "context_kind"
        elif key == "rolloutWeights":
            suggest = "rollout_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironmentRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironmentRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironmentRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_by: Optional[_builtins.str] = None,
                 clauses: Optional[Sequence['outputs.FeatureFlagEnvironmentRuleClause']] = None,
                 context_kind: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 rollout_weights: Optional[Sequence[_builtins.int]] = None,
                 variation: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        :param Sequence['FeatureFlagEnvironmentRuleClauseArgs'] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param _builtins.str context_kind: The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        :param _builtins.str description: A human-readable description of the targeting rule.
        :param Sequence[_builtins.int] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        :param _builtins.int variation: The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[_builtins.str]:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[Sequence['outputs.FeatureFlagEnvironmentRuleClause']]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A human-readable description of the targeting rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> Optional[_builtins.int]:
        """
        The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagEnvironmentRuleClause(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextKind":
            suggest = "context_kind"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironmentRuleClause. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironmentRuleClause.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironmentRuleClause.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str],
                 context_kind: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: The user attribute to operate on
        :param _builtins.str op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param Sequence[_builtins.str] values: The list of values associated with the rule clause.
        :param _builtins.str context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param _builtins.bool negate: Whether to negate the rule clause.
        :param _builtins.str value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> _builtins.str:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class FeatureFlagEnvironmentTarget(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str],
                 variation: _builtins.int):
        """
        :param Sequence[_builtins.str] values: List of `user` strings to target.
        :param _builtins.int variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagVariation(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The variation value. The value's type must correspond to the `variation_type` argument. For example: `variation_type = "boolean"` accepts only `true` or `false`. The `number` variation type accepts both floats and ints, but please note that any trailing zeroes on floats will be trimmed (i.e. `1.1` and `1.100` will both be converted to `1.1`).
        :param _builtins.str description: The feature flag's description.
        :param _builtins.str name: The human-readable name of the feature flag.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The variation value. The value's type must correspond to the `variation_type` argument. For example: `variation_type = "boolean"` accepts only `true` or `false`. The `number` variation type accepts both floats and ints, but please note that any trailing zeroes on floats will be trimmed (i.e. `1.1` and `1.100` will both be converted to `1.1`).
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The feature flag's description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The human-readable name of the feature flag.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FlagTriggerInstructions(dict):
    def __init__(__self__, *,
                 kind: _builtins.str):
        """
        :param _builtins.str kind: The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class MetricUrl(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 pattern: Optional[_builtins.str] = None,
                 substring: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        :param _builtins.str pattern: (Required for kind `regex`) The regex pattern to match by.
        :param _builtins.str substring: (Required for kind `substring`) The URL substring to match by.
        :param _builtins.str url: (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        pulumi.set(__self__, "kind", kind)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if substring is not None:
            pulumi.set(__self__, "substring", substring)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        """
        (Required for kind `regex`) The regex pattern to match by.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def substring(self) -> Optional[_builtins.str]:
        """
        (Required for kind `substring`) The URL substring to match by.
        """
        return pulumi.get(self, "substring")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ProjectDefaultClientSideAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usingEnvironmentId":
            suggest = "using_environment_id"
        elif key == "usingMobileKey":
            suggest = "using_mobile_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectDefaultClientSideAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectDefaultClientSideAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectDefaultClientSideAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 using_environment_id: _builtins.bool,
                 using_mobile_key: _builtins.bool):
        pulumi.set(__self__, "using_environment_id", using_environment_id)
        pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> _builtins.bool:
        return pulumi.get(self, "using_environment_id")

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> _builtins.bool:
        return pulumi.get(self, "using_mobile_key")


@pulumi.output_type
class ProjectEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "approvalSettings":
            suggest = "approval_settings"
        elif key == "clientSideId":
            suggest = "client_side_id"
        elif key == "confirmChanges":
            suggest = "confirm_changes"
        elif key == "defaultTrackEvents":
            suggest = "default_track_events"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "mobileKey":
            suggest = "mobile_key"
        elif key == "requireComments":
            suggest = "require_comments"
        elif key == "secureMode":
            suggest = "secure_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: _builtins.str,
                 key: _builtins.str,
                 name: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 approval_settings: Optional[Sequence['outputs.ProjectEnvironmentApprovalSetting']] = None,
                 client_side_id: Optional[_builtins.str] = None,
                 confirm_changes: Optional[_builtins.bool] = None,
                 critical: Optional[_builtins.bool] = None,
                 default_track_events: Optional[_builtins.bool] = None,
                 default_ttl: Optional[_builtins.int] = None,
                 mobile_key: Optional[_builtins.str] = None,
                 require_comments: Optional[_builtins.bool] = None,
                 secure_mode: Optional[_builtins.bool] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str color: The color swatch as an RGB hex value with no leading `#`. For example: `000000`
        :param _builtins.str key: The project-unique key for the environment. A change in this field will force the destruction of the existing resource and the creation of a new one.
        :param _builtins.str name: The name of the environment.
        :param _builtins.str api_key: The environment's SDK key.
        :param _builtins.str client_side_id: The environment's client-side ID.
        :param _builtins.bool confirm_changes: Set to `true` if this environment requires confirmation for flag and segment changes. This field will default to `false` when not set.
        :param _builtins.bool critical: Denotes whether the environment is critical.
        :param _builtins.bool default_track_events: Set to `true` to enable data export for every flag created in this environment after you configure this argument. This field will default to `false` when not set. To learn more, read [Data Export](https://docs.launchdarkly.com/home/data-export).
        :param _builtins.int default_ttl: The TTL for the environment. This must be between 0 and 60 minutes. The TTL setting only applies to environments using the PHP SDK. This field will default to `0` when not set. To learn more, read [TTL settings](https://docs.launchdarkly.com/home/organize/environments#ttl-settings).
        :param _builtins.str mobile_key: The environment's mobile key.
        :param _builtins.bool require_comments: Set to `true` if this environment requires comments for flag and segment changes. This field will default to `false` when not set.
        :param _builtins.bool secure_mode: Set to `true` to ensure a user of the client-side SDK cannot impersonate another user. This field will default to `false` when not set.
        :param Sequence[_builtins.str] tags: Tags associated with your resource.
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if approval_settings is not None:
            pulumi.set(__self__, "approval_settings", approval_settings)
        if client_side_id is not None:
            pulumi.set(__self__, "client_side_id", client_side_id)
        if confirm_changes is not None:
            pulumi.set(__self__, "confirm_changes", confirm_changes)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if default_track_events is not None:
            pulumi.set(__self__, "default_track_events", default_track_events)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if mobile_key is not None:
            pulumi.set(__self__, "mobile_key", mobile_key)
        if require_comments is not None:
            pulumi.set(__self__, "require_comments", require_comments)
        if secure_mode is not None:
            pulumi.set(__self__, "secure_mode", secure_mode)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def color(self) -> _builtins.str:
        """
        The color swatch as an RGB hex value with no leading `#`. For example: `000000`
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The project-unique key for the environment. A change in this field will force the destruction of the existing resource and the creation of a new one.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the environment.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        The environment's SDK key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="approvalSettings")
    def approval_settings(self) -> Optional[Sequence['outputs.ProjectEnvironmentApprovalSetting']]:
        return pulumi.get(self, "approval_settings")

    @_builtins.property
    @pulumi.getter(name="clientSideId")
    def client_side_id(self) -> Optional[_builtins.str]:
        """
        The environment's client-side ID.
        """
        return pulumi.get(self, "client_side_id")

    @_builtins.property
    @pulumi.getter(name="confirmChanges")
    def confirm_changes(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if this environment requires confirmation for flag and segment changes. This field will default to `false` when not set.
        """
        return pulumi.get(self, "confirm_changes")

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[_builtins.bool]:
        """
        Denotes whether the environment is critical.
        """
        return pulumi.get(self, "critical")

    @_builtins.property
    @pulumi.getter(name="defaultTrackEvents")
    def default_track_events(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to enable data export for every flag created in this environment after you configure this argument. This field will default to `false` when not set. To learn more, read [Data Export](https://docs.launchdarkly.com/home/data-export).
        """
        return pulumi.get(self, "default_track_events")

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[_builtins.int]:
        """
        The TTL for the environment. This must be between 0 and 60 minutes. The TTL setting only applies to environments using the PHP SDK. This field will default to `0` when not set. To learn more, read [TTL settings](https://docs.launchdarkly.com/home/organize/environments#ttl-settings).
        """
        return pulumi.get(self, "default_ttl")

    @_builtins.property
    @pulumi.getter(name="mobileKey")
    def mobile_key(self) -> Optional[_builtins.str]:
        """
        The environment's mobile key.
        """
        return pulumi.get(self, "mobile_key")

    @_builtins.property
    @pulumi.getter(name="requireComments")
    def require_comments(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if this environment requires comments for flag and segment changes. This field will default to `false` when not set.
        """
        return pulumi.get(self, "require_comments")

    @_builtins.property
    @pulumi.getter(name="secureMode")
    def secure_mode(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to ensure a user of the client-side SDK cannot impersonate another user. This field will default to `false` when not set.
        """
        return pulumi.get(self, "secure_mode")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Tags associated with your resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ProjectEnvironmentApprovalSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoApplyApprovedChanges":
            suggest = "auto_apply_approved_changes"
        elif key == "canApplyDeclinedChanges":
            suggest = "can_apply_declined_changes"
        elif key == "canReviewOwnRequest":
            suggest = "can_review_own_request"
        elif key == "minNumApprovals":
            suggest = "min_num_approvals"
        elif key == "requiredApprovalTags":
            suggest = "required_approval_tags"
        elif key == "serviceConfig":
            suggest = "service_config"
        elif key == "serviceKind":
            suggest = "service_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironmentApprovalSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironmentApprovalSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironmentApprovalSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_apply_approved_changes: Optional[_builtins.bool] = None,
                 can_apply_declined_changes: Optional[_builtins.bool] = None,
                 can_review_own_request: Optional[_builtins.bool] = None,
                 min_num_approvals: Optional[_builtins.int] = None,
                 required: Optional[_builtins.bool] = None,
                 required_approval_tags: Optional[Sequence[_builtins.str]] = None,
                 service_config: Optional[Mapping[str, _builtins.str]] = None,
                 service_kind: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_apply_approved_changes: Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        :param _builtins.bool can_apply_declined_changes: Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        :param _builtins.bool can_review_own_request: Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        :param _builtins.int min_num_approvals: The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        :param _builtins.bool required: Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        :param Sequence[_builtins.str] required_approval_tags: An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        :param Mapping[str, _builtins.str] service_config: The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:
               
               	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
               	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        :param _builtins.str service_kind: The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        if auto_apply_approved_changes is not None:
            pulumi.set(__self__, "auto_apply_approved_changes", auto_apply_approved_changes)
        if can_apply_declined_changes is not None:
            pulumi.set(__self__, "can_apply_declined_changes", can_apply_declined_changes)
        if can_review_own_request is not None:
            pulumi.set(__self__, "can_review_own_request", can_review_own_request)
        if min_num_approvals is not None:
            pulumi.set(__self__, "min_num_approvals", min_num_approvals)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if required_approval_tags is not None:
            pulumi.set(__self__, "required_approval_tags", required_approval_tags)
        if service_config is not None:
            pulumi.set(__self__, "service_config", service_config)
        if service_kind is not None:
            pulumi.set(__self__, "service_kind", service_kind)

    @_builtins.property
    @pulumi.getter(name="autoApplyApprovedChanges")
    def auto_apply_approved_changes(self) -> Optional[_builtins.bool]:
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        return pulumi.get(self, "auto_apply_approved_changes")

    @_builtins.property
    @pulumi.getter(name="canApplyDeclinedChanges")
    def can_apply_declined_changes(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        return pulumi.get(self, "can_apply_declined_changes")

    @_builtins.property
    @pulumi.getter(name="canReviewOwnRequest")
    def can_review_own_request(self) -> Optional[_builtins.bool]:
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        return pulumi.get(self, "can_review_own_request")

    @_builtins.property
    @pulumi.getter(name="minNumApprovals")
    def min_num_approvals(self) -> Optional[_builtins.int]:
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        return pulumi.get(self, "min_num_approvals")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="requiredApprovalTags")
    def required_approval_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        return pulumi.get(self, "required_approval_tags")

    @_builtins.property
    @pulumi.getter(name="serviceConfig")
    def service_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        return pulumi.get(self, "service_config")

    @_builtins.property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> Optional[_builtins.str]:
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        return pulumi.get(self, "service_kind")


@pulumi.output_type
class RelayProxyConfigurationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RelayProxyConfigurationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RelayProxyConfigurationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RelayProxyConfigurationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class SegmentExcludedContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextKind":
            suggest = "context_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SegmentExcludedContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SegmentExcludedContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SegmentExcludedContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param Sequence[_builtins.str] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SegmentIncludedContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextKind":
            suggest = "context_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SegmentIncludedContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SegmentIncludedContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SegmentIncludedContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param Sequence[_builtins.str] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SegmentRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketBy":
            suggest = "bucket_by"
        elif key == "rolloutContextKind":
            suggest = "rollout_context_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SegmentRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SegmentRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SegmentRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_by: Optional[_builtins.str] = None,
                 clauses: Optional[Sequence['outputs.SegmentRuleClause']] = None,
                 rollout_context_kind: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_by: The attribute by which to group contexts together.
        :param Sequence['SegmentRuleClauseArgs'] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param _builtins.str rollout_context_kind: The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        :param _builtins.int weight: The integer weight of the rule (between 1 and 100000).
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if rollout_context_kind is not None:
            pulumi.set(__self__, "rollout_context_kind", rollout_context_kind)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[_builtins.str]:
        """
        The attribute by which to group contexts together.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[Sequence['outputs.SegmentRuleClause']]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @_builtins.property
    @pulumi.getter(name="rolloutContextKind")
    def rollout_context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "rollout_context_kind")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The integer weight of the rule (between 1 and 100000).
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class SegmentRuleClause(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextKind":
            suggest = "context_kind"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SegmentRuleClause. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SegmentRuleClause.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SegmentRuleClause.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str],
                 context_kind: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: The user attribute to operate on
        :param _builtins.str op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param Sequence[_builtins.str] values: The list of values associated with the rule clause.
        :param _builtins.str context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param _builtins.bool negate: Whether to negate the rule clause.
        :param _builtins.str value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> _builtins.str:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class TeamMemberRoleAttribute(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class TeamRoleAttribute(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class WebhookStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notActions":
            suggest = "not_actions"
        elif key == "notResources":
            suggest = "not_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetAuditLogSubscriptionStatementResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetEnvironmentApprovalSettingResult(dict):
    def __init__(__self__, *,
                 can_apply_declined_changes: _builtins.bool,
                 can_review_own_request: _builtins.bool,
                 min_num_approvals: _builtins.int,
                 required: _builtins.bool,
                 required_approval_tags: Sequence[_builtins.str],
                 service_config: Mapping[str, _builtins.str],
                 service_kind: _builtins.str,
                 auto_apply_approved_changes: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool can_apply_declined_changes: Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        :param _builtins.bool can_review_own_request: Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        :param _builtins.int min_num_approvals: The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        :param _builtins.bool required: Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        :param Sequence[_builtins.str] required_approval_tags: An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        :param Mapping[str, _builtins.str] service_config: The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:
               
               	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
               	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        :param _builtins.str service_kind: The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        :param _builtins.bool auto_apply_approved_changes: Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        pulumi.set(__self__, "can_apply_declined_changes", can_apply_declined_changes)
        pulumi.set(__self__, "can_review_own_request", can_review_own_request)
        pulumi.set(__self__, "min_num_approvals", min_num_approvals)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "required_approval_tags", required_approval_tags)
        pulumi.set(__self__, "service_config", service_config)
        pulumi.set(__self__, "service_kind", service_kind)
        if auto_apply_approved_changes is not None:
            pulumi.set(__self__, "auto_apply_approved_changes", auto_apply_approved_changes)

    @_builtins.property
    @pulumi.getter(name="canApplyDeclinedChanges")
    def can_apply_declined_changes(self) -> _builtins.bool:
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        return pulumi.get(self, "can_apply_declined_changes")

    @_builtins.property
    @pulumi.getter(name="canReviewOwnRequest")
    def can_review_own_request(self) -> _builtins.bool:
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        return pulumi.get(self, "can_review_own_request")

    @_builtins.property
    @pulumi.getter(name="minNumApprovals")
    def min_num_approvals(self) -> _builtins.int:
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        return pulumi.get(self, "min_num_approvals")

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter(name="requiredApprovalTags")
    def required_approval_tags(self) -> Sequence[_builtins.str]:
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        return pulumi.get(self, "required_approval_tags")

    @_builtins.property
    @pulumi.getter(name="serviceConfig")
    def service_config(self) -> Mapping[str, _builtins.str]:
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        return pulumi.get(self, "service_config")

    @_builtins.property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> _builtins.str:
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        return pulumi.get(self, "service_kind")

    @_builtins.property
    @pulumi.getter(name="autoApplyApprovedChanges")
    def auto_apply_approved_changes(self) -> Optional[_builtins.bool]:
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        return pulumi.get(self, "auto_apply_approved_changes")


@pulumi.output_type
class GetFeatureFlagClientSideAvailabilityResult(dict):
    def __init__(__self__, *,
                 using_environment_id: _builtins.bool,
                 using_mobile_key: _builtins.bool):
        """
        :param _builtins.bool using_environment_id: Whether this flag is available to SDKs using the client-side ID.
        :param _builtins.bool using_mobile_key: Whether this flag is available to SDKs using a mobile key.
        """
        pulumi.set(__self__, "using_environment_id", using_environment_id)
        pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> _builtins.bool:
        """
        Whether this flag is available to SDKs using the client-side ID.
        """
        return pulumi.get(self, "using_environment_id")

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> _builtins.bool:
        """
        Whether this flag is available to SDKs using a mobile key.
        """
        return pulumi.get(self, "using_mobile_key")


@pulumi.output_type
class GetFeatureFlagCustomPropertyResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The unique custom property key.
        :param _builtins.str name: The name of the custom property.
        :param Sequence[_builtins.str] values: The list of custom property value strings.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The unique custom property key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the custom property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of custom property value strings.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetFeatureFlagDefaultResult(dict):
    def __init__(__self__, *,
                 off_variation: _builtins.int,
                 on_variation: _builtins.int):
        """
        :param _builtins.int off_variation: The index of the variation the flag will default to in all new environments when off.
        :param _builtins.int on_variation: The index of the variation the flag will default to in all new environments when on.
        """
        pulumi.set(__self__, "off_variation", off_variation)
        pulumi.set(__self__, "on_variation", on_variation)

    @_builtins.property
    @pulumi.getter(name="offVariation")
    def off_variation(self) -> _builtins.int:
        """
        The index of the variation the flag will default to in all new environments when off.
        """
        return pulumi.get(self, "off_variation")

    @_builtins.property
    @pulumi.getter(name="onVariation")
    def on_variation(self) -> _builtins.int:
        """
        The index of the variation the flag will default to in all new environments when on.
        """
        return pulumi.get(self, "on_variation")


@pulumi.output_type
class GetFeatureFlagEnvironmentContextTargetResult(dict):
    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str],
                 variation: _builtins.int):
        """
        :param _builtins.str context_kind: The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        :param Sequence[_builtins.str] values: List of `user` strings to target.
        :param _builtins.int variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class GetFeatureFlagEnvironmentFallthroughResult(dict):
    def __init__(__self__, *,
                 bucket_by: _builtins.str,
                 context_kind: _builtins.str,
                 variation: _builtins.int,
                 rollout_weights: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.str bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        :param _builtins.str context_kind: The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        :param _builtins.int variation: The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        :param Sequence[_builtins.int] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        pulumi.set(__self__, "bucket_by", bucket_by)
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "variation", variation)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> _builtins.str:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "variation")

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")


@pulumi.output_type
class GetFeatureFlagEnvironmentPrerequisiteResult(dict):
    def __init__(__self__, *,
                 flag_key: _builtins.str,
                 variation: _builtins.int):
        """
        :param _builtins.str flag_key: The prerequisite feature flag's `key`.
        :param _builtins.int variation: The index of the prerequisite feature flag's variation to target.
        """
        pulumi.set(__self__, "flag_key", flag_key)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="flagKey")
    def flag_key(self) -> _builtins.str:
        """
        The prerequisite feature flag's `key`.
        """
        return pulumi.get(self, "flag_key")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the prerequisite feature flag's variation to target.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class GetFeatureFlagEnvironmentRuleResult(dict):
    def __init__(__self__, *,
                 bucket_by: Optional[_builtins.str] = None,
                 clauses: Optional[Sequence['outputs.GetFeatureFlagEnvironmentRuleClauseResult']] = None,
                 context_kind: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 rollout_weights: Optional[Sequence[_builtins.int]] = None,
                 variation: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        :param Sequence['GetFeatureFlagEnvironmentRuleClauseArgs'] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param _builtins.str context_kind: The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        :param _builtins.str description: A human-readable description of the targeting rule.
        :param Sequence[_builtins.int] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        :param _builtins.int variation: The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[_builtins.str]:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[Sequence['outputs.GetFeatureFlagEnvironmentRuleClauseResult']]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A human-readable description of the targeting rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> Optional[_builtins.int]:
        """
        The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class GetFeatureFlagEnvironmentRuleClauseResult(dict):
    def __init__(__self__, *,
                 attribute: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str],
                 context_kind: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: The user attribute to operate on
        :param _builtins.str op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param Sequence[_builtins.str] values: The list of values associated with the rule clause.
        :param _builtins.str context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param _builtins.bool negate: Whether to negate the rule clause.
        :param _builtins.str value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> _builtins.str:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetFeatureFlagEnvironmentTargetResult(dict):
    def __init__(__self__, *,
                 values: Sequence[_builtins.str],
                 variation: _builtins.int):
        """
        :param Sequence[_builtins.str] values: List of `user` strings to target.
        :param _builtins.int variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def variation(self) -> _builtins.int:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class GetFeatureFlagVariationResult(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The variation's description.
        :param _builtins.str name: The name of the variation.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The variation's description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the variation.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFlagTriggerInstructionResult(dict):
    def __init__(__self__, *,
                 kind: _builtins.str):
        """
        :param _builtins.str kind: The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetMetricUrlResult(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 pattern: Optional[_builtins.str] = None,
                 substring: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        :param _builtins.str pattern: (Required for kind `regex`) The regex pattern to match by.
        :param _builtins.str substring: (Required for kind `substring`) The URL substring to match by.
        :param _builtins.str url: (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        pulumi.set(__self__, "kind", kind)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if substring is not None:
            pulumi.set(__self__, "substring", substring)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        """
        (Required for kind `regex`) The regex pattern to match by.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def substring(self) -> Optional[_builtins.str]:
        """
        (Required for kind `substring`) The URL substring to match by.
        """
        return pulumi.get(self, "substring")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetProjectClientSideAvailabilityResult(dict):
    def __init__(__self__, *,
                 using_environment_id: Optional[_builtins.bool] = None,
                 using_mobile_key: Optional[_builtins.bool] = None):
        if using_environment_id is not None:
            pulumi.set(__self__, "using_environment_id", using_environment_id)
        if using_mobile_key is not None:
            pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "using_environment_id")

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "using_mobile_key")


@pulumi.output_type
class GetProjectDefaultClientSideAvailabilityResult(dict):
    def __init__(__self__, *,
                 using_environment_id: _builtins.bool,
                 using_mobile_key: _builtins.bool):
        pulumi.set(__self__, "using_environment_id", using_environment_id)
        pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> _builtins.bool:
        return pulumi.get(self, "using_environment_id")

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> _builtins.bool:
        return pulumi.get(self, "using_mobile_key")


@pulumi.output_type
class GetRelayProxyConfigurationPolicyResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetSegmentExcludedContextResult(dict):
    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param Sequence[_builtins.str] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSegmentIncludedContextResult(dict):
    def __init__(__self__, *,
                 context_kind: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param Sequence[_builtins.str] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> _builtins.str:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSegmentRuleResult(dict):
    def __init__(__self__, *,
                 bucket_by: Optional[_builtins.str] = None,
                 clauses: Optional[Sequence['outputs.GetSegmentRuleClauseResult']] = None,
                 rollout_context_kind: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_by: The attribute by which to group contexts together.
        :param Sequence['GetSegmentRuleClauseArgs'] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param _builtins.str rollout_context_kind: The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        :param _builtins.int weight: The integer weight of the rule (between 1 and 100000).
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if rollout_context_kind is not None:
            pulumi.set(__self__, "rollout_context_kind", rollout_context_kind)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[_builtins.str]:
        """
        The attribute by which to group contexts together.
        """
        return pulumi.get(self, "bucket_by")

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[Sequence['outputs.GetSegmentRuleClauseResult']]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @_builtins.property
    @pulumi.getter(name="rolloutContextKind")
    def rollout_context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "rollout_context_kind")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The integer weight of the rule (between 1 and 100000).
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetSegmentRuleClauseResult(dict):
    def __init__(__self__, *,
                 attribute: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str],
                 context_kind: Optional[_builtins.str] = None,
                 negate: Optional[_builtins.bool] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute: The user attribute to operate on
        :param _builtins.str op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param Sequence[_builtins.str] values: The list of values associated with the rule clause.
        :param _builtins.str context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param _builtins.bool negate: Whether to negate the rule clause.
        :param _builtins.str value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> _builtins.str:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[_builtins.str]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[_builtins.bool]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetTeamMaintainerResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 last_name: _builtins.str,
                 role: _builtins.str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        return pulumi.get(self, "role")


@pulumi.output_type
class GetTeamMemberRoleAttributeResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTeamMembersTeamMemberResult(dict):
    def __init__(__self__, *,
                 custom_roles: Sequence[_builtins.str],
                 email: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 last_name: _builtins.str,
                 role: _builtins.str,
                 role_attributes: Sequence['outputs.GetTeamMembersTeamMemberRoleAttributeResult']):
        """
        :param Sequence[_builtins.str] custom_roles: The list of custom roles keys associated with the team member. Custom roles are only available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact LaunchDarkly Sales](https://launchdarkly.com/contact-sales/).
        :param _builtins.str email: The unique email address associated with the team member.
        :param _builtins.str first_name: The team member's given name.
        :param _builtins.str id: The 24 character alphanumeric ID of the team member.
        :param _builtins.str last_name: The team member's family name.
        :param _builtins.str role: The role associated with team member. Possible roles are `owner`, `reader`, `writer`, or `admin`.
        :param Sequence['GetTeamMembersTeamMemberRoleAttributeArgs'] role_attributes: A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
        """
        pulumi.set(__self__, "custom_roles", custom_roles)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "role_attributes", role_attributes)

    @_builtins.property
    @pulumi.getter(name="customRoles")
    def custom_roles(self) -> Sequence[_builtins.str]:
        """
        The list of custom roles keys associated with the team member. Custom roles are only available to customers on an Enterprise plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact LaunchDarkly Sales](https://launchdarkly.com/contact-sales/).
        """
        return pulumi.get(self, "custom_roles")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The unique email address associated with the team member.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        The team member's given name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The 24 character alphanumeric ID of the team member.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        The team member's family name.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role associated with team member. Possible roles are `owner`, `reader`, `writer`, or `admin`.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="roleAttributes")
    def role_attributes(self) -> Sequence['outputs.GetTeamMembersTeamMemberRoleAttributeResult']:
        """
        A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
        """
        return pulumi.get(self, "role_attributes")


@pulumi.output_type
class GetTeamMembersTeamMemberRoleAttributeResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTeamRoleAttributeResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetWebhookStatementResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 actions: Optional[Sequence[_builtins.str]] = None,
                 not_actions: Optional[Sequence[_builtins.str]] = None,
                 not_resources: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param Sequence[_builtins.str] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param Sequence[_builtins.str] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param Sequence[_builtins.str] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param Sequence[_builtins.str] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")


