# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetMetricResult',
    'AwaitableGetMetricResult',
    'get_metric',
    'get_metric_output',
]

@pulumi.output_type
class GetMetricResult:
    """
    A collection of values returned by getMetric.
    """
    def __init__(__self__, analysis_type=None, description=None, event_key=None, id=None, include_units_without_events=None, is_active=None, is_numeric=None, key=None, kind=None, maintainer_id=None, name=None, percentile_value=None, project_key=None, randomization_units=None, selector=None, success_criteria=None, tags=None, unit=None, unit_aggregation_type=None, urls=None, version=None):
        if analysis_type and not isinstance(analysis_type, str):
            raise TypeError("Expected argument 'analysis_type' to be a str")
        pulumi.set(__self__, "analysis_type", analysis_type)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if event_key and not isinstance(event_key, str):
            raise TypeError("Expected argument 'event_key' to be a str")
        pulumi.set(__self__, "event_key", event_key)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if include_units_without_events and not isinstance(include_units_without_events, bool):
            raise TypeError("Expected argument 'include_units_without_events' to be a bool")
        pulumi.set(__self__, "include_units_without_events", include_units_without_events)
        if is_active and not isinstance(is_active, bool):
            raise TypeError("Expected argument 'is_active' to be a bool")
        pulumi.set(__self__, "is_active", is_active)
        if is_numeric and not isinstance(is_numeric, bool):
            raise TypeError("Expected argument 'is_numeric' to be a bool")
        pulumi.set(__self__, "is_numeric", is_numeric)
        if key and not isinstance(key, str):
            raise TypeError("Expected argument 'key' to be a str")
        pulumi.set(__self__, "key", key)
        if kind and not isinstance(kind, str):
            raise TypeError("Expected argument 'kind' to be a str")
        pulumi.set(__self__, "kind", kind)
        if maintainer_id and not isinstance(maintainer_id, str):
            raise TypeError("Expected argument 'maintainer_id' to be a str")
        pulumi.set(__self__, "maintainer_id", maintainer_id)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if percentile_value and not isinstance(percentile_value, int):
            raise TypeError("Expected argument 'percentile_value' to be a int")
        pulumi.set(__self__, "percentile_value", percentile_value)
        if project_key and not isinstance(project_key, str):
            raise TypeError("Expected argument 'project_key' to be a str")
        pulumi.set(__self__, "project_key", project_key)
        if randomization_units and not isinstance(randomization_units, list):
            raise TypeError("Expected argument 'randomization_units' to be a list")
        pulumi.set(__self__, "randomization_units", randomization_units)
        if selector and not isinstance(selector, str):
            raise TypeError("Expected argument 'selector' to be a str")
        pulumi.set(__self__, "selector", selector)
        if success_criteria and not isinstance(success_criteria, str):
            raise TypeError("Expected argument 'success_criteria' to be a str")
        pulumi.set(__self__, "success_criteria", success_criteria)
        if tags and not isinstance(tags, list):
            raise TypeError("Expected argument 'tags' to be a list")
        pulumi.set(__self__, "tags", tags)
        if unit and not isinstance(unit, str):
            raise TypeError("Expected argument 'unit' to be a str")
        pulumi.set(__self__, "unit", unit)
        if unit_aggregation_type and not isinstance(unit_aggregation_type, str):
            raise TypeError("Expected argument 'unit_aggregation_type' to be a str")
        pulumi.set(__self__, "unit_aggregation_type", unit_aggregation_type)
        if urls and not isinstance(urls, list):
            raise TypeError("Expected argument 'urls' to be a list")
        pulumi.set(__self__, "urls", urls)
        if version and not isinstance(version, int):
            raise TypeError("Expected argument 'version' to be a int")
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="analysisType")
    def analysis_type(self) -> _builtins.str:
        """
        The method for analyzing metric events. Available choices are `mean` and `percentile`.
        """
        return pulumi.get(self, "analysis_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the metric's purpose.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="eventKey")
    def event_key(self) -> _builtins.str:
        """
        The event key for your metric (if custom metric)
        """
        return pulumi.get(self, "event_key")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="includeUnitsWithoutEvents")
    def include_units_without_events(self) -> _builtins.bool:
        """
        Include units that did not send any events and set their value to 0.
        """
        return pulumi.get(self, "include_units_without_events")

    @_builtins.property
    @pulumi.getter(name="isActive")
    @_utilities.deprecated("""No longer in use. This field will be removed in a future major release of the LaunchDarkly provider.""")
    def is_active(self) -> _builtins.bool:
        """
        Ignored. All metrics are considered active.
        """
        return pulumi.get(self, "is_active")

    @_builtins.property
    @pulumi.getter(name="isNumeric")
    def is_numeric(self) -> _builtins.bool:
        """
        Whether a `custom` metric is a numeric metric or not.
        """
        return pulumi.get(self, "is_numeric")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The unique key that references the metric. A change in this field will force the destruction of the existing resource and the creation of a new one.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The metric type. Available choices are `click`, `custom`, and `pageview`.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="maintainerId")
    def maintainer_id(self) -> _builtins.str:
        """
        The LaunchDarkly member ID of the member who will maintain the metric. If not set, the API will automatically apply the member associated with your Terraform API key or the most recently-set maintainer
        """
        return pulumi.get(self, "maintainer_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The human-friendly name for the metric.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="percentileValue")
    def percentile_value(self) -> _builtins.int:
        """
        The percentile for the analysis method. An integer denoting the target percentile between 0 and 100. Required when analysis_type is percentile.
        """
        return pulumi.get(self, "percentile_value")

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> _builtins.str:
        """
        The metrics's project key. A change in this field will force the destruction of the existing resource and the creation of a new one.
        """
        return pulumi.get(self, "project_key")

    @_builtins.property
    @pulumi.getter(name="randomizationUnits")
    def randomization_units(self) -> Sequence[_builtins.str]:
        """
        A set of one or more context kinds that this metric can measure events from. Metrics can only use context kinds marked as "Available for experiments." For more information, read [Allocating experiment audiences](https://docs.launchdarkly.com/home/creating-experiments/allocation).
        """
        return pulumi.get(self, "randomization_units")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> _builtins.str:
        """
        The CSS selector for your metric (if click metric)
        """
        return pulumi.get(self, "selector")

    @_builtins.property
    @pulumi.getter(name="successCriteria")
    def success_criteria(self) -> _builtins.str:
        """
        The success criteria for your metric (if numeric metric). Available choices are `HigherThanBaseline` and `LowerThanBaseline`.
        """
        return pulumi.get(self, "success_criteria")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        Tags associated with your resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        (Required for kind `custom`) The unit for numeric `custom` metrics.
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter(name="unitAggregationType")
    def unit_aggregation_type(self) -> _builtins.str:
        """
        The method by which multiple unit event values are aggregated. Available choices are `average` and `sum`.
        """
        return pulumi.get(self, "unit_aggregation_type")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence['outputs.GetMetricUrlResult']:
        """
        List of nested `url` blocks describing URLs that you want to associate with the metric.
        """
        return pulumi.get(self, "urls")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        Version of the metric
        """
        return pulumi.get(self, "version")


class AwaitableGetMetricResult(GetMetricResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetMetricResult(
            analysis_type=self.analysis_type,
            description=self.description,
            event_key=self.event_key,
            id=self.id,
            include_units_without_events=self.include_units_without_events,
            is_active=self.is_active,
            is_numeric=self.is_numeric,
            key=self.key,
            kind=self.kind,
            maintainer_id=self.maintainer_id,
            name=self.name,
            percentile_value=self.percentile_value,
            project_key=self.project_key,
            randomization_units=self.randomization_units,
            selector=self.selector,
            success_criteria=self.success_criteria,
            tags=self.tags,
            unit=self.unit,
            unit_aggregation_type=self.unit_aggregation_type,
            urls=self.urls,
            version=self.version)


def get_metric(is_active: Optional[_builtins.bool] = None,
               key: Optional[_builtins.str] = None,
               project_key: Optional[_builtins.str] = None,
               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetMetricResult:
    """
    Provides a LaunchDarkly metric data source.

    This data source allows you to retrieve metric information from your LaunchDarkly organization.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_launchdarkly as launchdarkly

    example = launchdarkly.get_metric(key="example-metric",
        project_key="example-project")
    ```


    :param _builtins.bool is_active: Ignored. All metrics are considered active.
    :param _builtins.str key: The unique key that references the metric. A change in this field will force the destruction of the existing resource and the creation of a new one.
    :param _builtins.str project_key: The metrics's project key. A change in this field will force the destruction of the existing resource and the creation of a new one.
    """
    __args__ = dict()
    __args__['isActive'] = is_active
    __args__['key'] = key
    __args__['projectKey'] = project_key
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('launchdarkly:index/getMetric:getMetric', __args__, opts=opts, typ=GetMetricResult).value

    return AwaitableGetMetricResult(
        analysis_type=pulumi.get(__ret__, 'analysis_type'),
        description=pulumi.get(__ret__, 'description'),
        event_key=pulumi.get(__ret__, 'event_key'),
        id=pulumi.get(__ret__, 'id'),
        include_units_without_events=pulumi.get(__ret__, 'include_units_without_events'),
        is_active=pulumi.get(__ret__, 'is_active'),
        is_numeric=pulumi.get(__ret__, 'is_numeric'),
        key=pulumi.get(__ret__, 'key'),
        kind=pulumi.get(__ret__, 'kind'),
        maintainer_id=pulumi.get(__ret__, 'maintainer_id'),
        name=pulumi.get(__ret__, 'name'),
        percentile_value=pulumi.get(__ret__, 'percentile_value'),
        project_key=pulumi.get(__ret__, 'project_key'),
        randomization_units=pulumi.get(__ret__, 'randomization_units'),
        selector=pulumi.get(__ret__, 'selector'),
        success_criteria=pulumi.get(__ret__, 'success_criteria'),
        tags=pulumi.get(__ret__, 'tags'),
        unit=pulumi.get(__ret__, 'unit'),
        unit_aggregation_type=pulumi.get(__ret__, 'unit_aggregation_type'),
        urls=pulumi.get(__ret__, 'urls'),
        version=pulumi.get(__ret__, 'version'))
def get_metric_output(is_active: Optional[pulumi.Input[Optional[_builtins.bool]]] = None,
                      key: Optional[pulumi.Input[_builtins.str]] = None,
                      project_key: Optional[pulumi.Input[_builtins.str]] = None,
                      opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetMetricResult]:
    """
    Provides a LaunchDarkly metric data source.

    This data source allows you to retrieve metric information from your LaunchDarkly organization.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_launchdarkly as launchdarkly

    example = launchdarkly.get_metric(key="example-metric",
        project_key="example-project")
    ```


    :param _builtins.bool is_active: Ignored. All metrics are considered active.
    :param _builtins.str key: The unique key that references the metric. A change in this field will force the destruction of the existing resource and the creation of a new one.
    :param _builtins.str project_key: The metrics's project key. A change in this field will force the destruction of the existing resource and the creation of a new one.
    """
    __args__ = dict()
    __args__['isActive'] = is_active
    __args__['key'] = key
    __args__['projectKey'] = project_key
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('launchdarkly:index/getMetric:getMetric', __args__, opts=opts, typ=GetMetricResult)
    return __ret__.apply(lambda __response__: GetMetricResult(
        analysis_type=pulumi.get(__response__, 'analysis_type'),
        description=pulumi.get(__response__, 'description'),
        event_key=pulumi.get(__response__, 'event_key'),
        id=pulumi.get(__response__, 'id'),
        include_units_without_events=pulumi.get(__response__, 'include_units_without_events'),
        is_active=pulumi.get(__response__, 'is_active'),
        is_numeric=pulumi.get(__response__, 'is_numeric'),
        key=pulumi.get(__response__, 'key'),
        kind=pulumi.get(__response__, 'kind'),
        maintainer_id=pulumi.get(__response__, 'maintainer_id'),
        name=pulumi.get(__response__, 'name'),
        percentile_value=pulumi.get(__response__, 'percentile_value'),
        project_key=pulumi.get(__response__, 'project_key'),
        randomization_units=pulumi.get(__response__, 'randomization_units'),
        selector=pulumi.get(__response__, 'selector'),
        success_criteria=pulumi.get(__response__, 'success_criteria'),
        tags=pulumi.get(__response__, 'tags'),
        unit=pulumi.get(__response__, 'unit'),
        unit_aggregation_type=pulumi.get(__response__, 'unit_aggregation_type'),
        urls=pulumi.get(__response__, 'urls'),
        version=pulumi.get(__response__, 'version')))
