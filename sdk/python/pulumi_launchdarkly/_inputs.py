# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessTokenInlineRoleArgs',
    'AccessTokenInlineRoleArgsDict',
    'AccessTokenPolicyStatementArgs',
    'AccessTokenPolicyStatementArgsDict',
    'AuditLogSubscriptionStatementArgs',
    'AuditLogSubscriptionStatementArgsDict',
    'CustomRolePolicyArgs',
    'CustomRolePolicyArgsDict',
    'CustomRolePolicyStatementArgs',
    'CustomRolePolicyStatementArgsDict',
    'EnvironmentApprovalSettingArgs',
    'EnvironmentApprovalSettingArgsDict',
    'FeatureFlagClientSideAvailabilityArgs',
    'FeatureFlagClientSideAvailabilityArgsDict',
    'FeatureFlagCustomPropertyArgs',
    'FeatureFlagCustomPropertyArgsDict',
    'FeatureFlagDefaultsArgs',
    'FeatureFlagDefaultsArgsDict',
    'FeatureFlagEnvironmentContextTargetArgs',
    'FeatureFlagEnvironmentContextTargetArgsDict',
    'FeatureFlagEnvironmentFallthroughArgs',
    'FeatureFlagEnvironmentFallthroughArgsDict',
    'FeatureFlagEnvironmentPrerequisiteArgs',
    'FeatureFlagEnvironmentPrerequisiteArgsDict',
    'FeatureFlagEnvironmentRuleArgs',
    'FeatureFlagEnvironmentRuleArgsDict',
    'FeatureFlagEnvironmentRuleClauseArgs',
    'FeatureFlagEnvironmentRuleClauseArgsDict',
    'FeatureFlagEnvironmentTargetArgs',
    'FeatureFlagEnvironmentTargetArgsDict',
    'FeatureFlagVariationArgs',
    'FeatureFlagVariationArgsDict',
    'FlagTriggerInstructionsArgs',
    'FlagTriggerInstructionsArgsDict',
    'MetricUrlArgs',
    'MetricUrlArgsDict',
    'ProjectDefaultClientSideAvailabilityArgs',
    'ProjectDefaultClientSideAvailabilityArgsDict',
    'ProjectEnvironmentArgs',
    'ProjectEnvironmentArgsDict',
    'ProjectEnvironmentApprovalSettingArgs',
    'ProjectEnvironmentApprovalSettingArgsDict',
    'RelayProxyConfigurationPolicyArgs',
    'RelayProxyConfigurationPolicyArgsDict',
    'SegmentExcludedContextArgs',
    'SegmentExcludedContextArgsDict',
    'SegmentIncludedContextArgs',
    'SegmentIncludedContextArgsDict',
    'SegmentRuleArgs',
    'SegmentRuleArgsDict',
    'SegmentRuleClauseArgs',
    'SegmentRuleClauseArgsDict',
    'TeamMemberRoleAttributeArgs',
    'TeamMemberRoleAttributeArgsDict',
    'TeamRoleAttributeArgs',
    'TeamRoleAttributeArgsDict',
    'WebhookStatementArgs',
    'WebhookStatementArgsDict',
    'GetTeamMemberRoleAttributeArgs',
    'GetTeamMemberRoleAttributeArgsDict',
    'GetTeamRoleAttributeArgs',
    'GetTeamRoleAttributeArgsDict',
]

MYPY = False

if not MYPY:
    class AccessTokenInlineRoleArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    AccessTokenInlineRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessTokenInlineRoleArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class AccessTokenPolicyStatementArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    AccessTokenPolicyStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessTokenPolicyStatementArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class AuditLogSubscriptionStatementArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    AuditLogSubscriptionStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuditLogSubscriptionStatementArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class CustomRolePolicyArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        effect: pulumi.Input[_builtins.str]
        resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    CustomRolePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRolePolicyArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 effect: pulumi.Input[_builtins.str],
                 resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class CustomRolePolicyStatementArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    CustomRolePolicyStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomRolePolicyStatementArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class EnvironmentApprovalSettingArgsDict(TypedDict):
        auto_apply_approved_changes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        can_apply_declined_changes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        can_review_own_request: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        min_num_approvals: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        required_approval_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        service_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        service_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
elif False:
    EnvironmentApprovalSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentApprovalSettingArgs:
    def __init__(__self__, *,
                 auto_apply_approved_changes: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_apply_declined_changes: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_review_own_request: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_num_approvals: Optional[pulumi.Input[_builtins.int]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 required_approval_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 service_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 service_kind: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_apply_approved_changes: Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        :param pulumi.Input[_builtins.bool] can_apply_declined_changes: Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        :param pulumi.Input[_builtins.bool] can_review_own_request: Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        :param pulumi.Input[_builtins.int] min_num_approvals: The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        :param pulumi.Input[_builtins.bool] required: Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] required_approval_tags: An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] service_config: The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:
               
               	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
               	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        :param pulumi.Input[_builtins.str] service_kind: The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        if auto_apply_approved_changes is not None:
            pulumi.set(__self__, "auto_apply_approved_changes", auto_apply_approved_changes)
        if can_apply_declined_changes is not None:
            pulumi.set(__self__, "can_apply_declined_changes", can_apply_declined_changes)
        if can_review_own_request is not None:
            pulumi.set(__self__, "can_review_own_request", can_review_own_request)
        if min_num_approvals is not None:
            pulumi.set(__self__, "min_num_approvals", min_num_approvals)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if required_approval_tags is not None:
            pulumi.set(__self__, "required_approval_tags", required_approval_tags)
        if service_config is not None:
            pulumi.set(__self__, "service_config", service_config)
        if service_kind is not None:
            pulumi.set(__self__, "service_kind", service_kind)

    @_builtins.property
    @pulumi.getter(name="autoApplyApprovedChanges")
    def auto_apply_approved_changes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        return pulumi.get(self, "auto_apply_approved_changes")

    @auto_apply_approved_changes.setter
    def auto_apply_approved_changes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_apply_approved_changes", value)

    @_builtins.property
    @pulumi.getter(name="canApplyDeclinedChanges")
    def can_apply_declined_changes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        return pulumi.get(self, "can_apply_declined_changes")

    @can_apply_declined_changes.setter
    def can_apply_declined_changes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_apply_declined_changes", value)

    @_builtins.property
    @pulumi.getter(name="canReviewOwnRequest")
    def can_review_own_request(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        return pulumi.get(self, "can_review_own_request")

    @can_review_own_request.setter
    def can_review_own_request(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_review_own_request", value)

    @_builtins.property
    @pulumi.getter(name="minNumApprovals")
    def min_num_approvals(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        return pulumi.get(self, "min_num_approvals")

    @min_num_approvals.setter
    def min_num_approvals(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_num_approvals", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter(name="requiredApprovalTags")
    def required_approval_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        return pulumi.get(self, "required_approval_tags")

    @required_approval_tags.setter
    def required_approval_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "required_approval_tags", value)

    @_builtins.property
    @pulumi.getter(name="serviceConfig")
    def service_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        return pulumi.get(self, "service_config")

    @service_config.setter
    def service_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "service_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        return pulumi.get(self, "service_kind")

    @service_kind.setter
    def service_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_kind", value)


if not MYPY:
    class FeatureFlagClientSideAvailabilityArgsDict(TypedDict):
        using_environment_id: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this flag is available to SDKs using the client-side ID.
        """
        using_mobile_key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this flag is available to SDKs using a mobile key.
        """
elif False:
    FeatureFlagClientSideAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagClientSideAvailabilityArgs:
    def __init__(__self__, *,
                 using_environment_id: Optional[pulumi.Input[_builtins.bool]] = None,
                 using_mobile_key: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] using_environment_id: Whether this flag is available to SDKs using the client-side ID.
        :param pulumi.Input[_builtins.bool] using_mobile_key: Whether this flag is available to SDKs using a mobile key.
        """
        if using_environment_id is not None:
            pulumi.set(__self__, "using_environment_id", using_environment_id)
        if using_mobile_key is not None:
            pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this flag is available to SDKs using the client-side ID.
        """
        return pulumi.get(self, "using_environment_id")

    @using_environment_id.setter
    def using_environment_id(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "using_environment_id", value)

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this flag is available to SDKs using a mobile key.
        """
        return pulumi.get(self, "using_mobile_key")

    @using_mobile_key.setter
    def using_mobile_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "using_mobile_key", value)


if not MYPY:
    class FeatureFlagCustomPropertyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The unique custom property key.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the custom property.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of custom property value strings.
        """
elif False:
    FeatureFlagCustomPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagCustomPropertyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The unique custom property key.
        :param pulumi.Input[_builtins.str] name: The name of the custom property.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of custom property value strings.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The unique custom property key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the custom property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of custom property value strings.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class FeatureFlagDefaultsArgsDict(TypedDict):
        off_variation: pulumi.Input[_builtins.int]
        """
        The index of the variation the flag will default to in all new environments when off.
        """
        on_variation: pulumi.Input[_builtins.int]
        """
        The index of the variation the flag will default to in all new environments when on.
        """
elif False:
    FeatureFlagDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagDefaultsArgs:
    def __init__(__self__, *,
                 off_variation: pulumi.Input[_builtins.int],
                 on_variation: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] off_variation: The index of the variation the flag will default to in all new environments when off.
        :param pulumi.Input[_builtins.int] on_variation: The index of the variation the flag will default to in all new environments when on.
        """
        pulumi.set(__self__, "off_variation", off_variation)
        pulumi.set(__self__, "on_variation", on_variation)

    @_builtins.property
    @pulumi.getter(name="offVariation")
    def off_variation(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the variation the flag will default to in all new environments when off.
        """
        return pulumi.get(self, "off_variation")

    @off_variation.setter
    def off_variation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "off_variation", value)

    @_builtins.property
    @pulumi.getter(name="onVariation")
    def on_variation(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the variation the flag will default to in all new environments when on.
        """
        return pulumi.get(self, "on_variation")

    @on_variation.setter
    def on_variation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "on_variation", value)


if not MYPY:
    class FeatureFlagEnvironmentContextTargetArgsDict(TypedDict):
        context_kind: pulumi.Input[_builtins.str]
        """
        The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of `user` strings to target.
        """
        variation: pulumi.Input[_builtins.int]
        """
        The index of the variation to serve if a user target value is matched.
        """
elif False:
    FeatureFlagEnvironmentContextTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentContextTargetArgs:
    def __init__(__self__, *,
                 context_kind: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 variation: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] context_kind: The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of `user` strings to target.
        :param pulumi.Input[_builtins.int] variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The context kind on which the flag should target in this environment. User (`user`) targets should be specified as `targets` attribute blocks.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagEnvironmentFallthroughArgsDict(TypedDict):
        bucket_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        """
        context_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        """
        rollout_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        variation: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
elif False:
    FeatureFlagEnvironmentFallthroughArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentFallthroughArgs:
    def __init__(__self__, *,
                 bucket_by: Optional[pulumi.Input[_builtins.str]] = None,
                 context_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_weights: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 variation: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        :param pulumi.Input[_builtins.int] variation: The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if rollout_weights is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @bucket_by.setter
    def bucket_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_by", value)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The context kind associated with the specified rollout. This argument is only valid if rollout_weights is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")

    @rollout_weights.setter
    def rollout_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "rollout_weights", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default integer variation index to serve if no `prerequisites`, `target`, or `rules` apply. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagEnvironmentPrerequisiteArgsDict(TypedDict):
        flag_key: pulumi.Input[_builtins.str]
        """
        The prerequisite feature flag's `key`.
        """
        variation: pulumi.Input[_builtins.int]
        """
        The index of the prerequisite feature flag's variation to target.
        """
elif False:
    FeatureFlagEnvironmentPrerequisiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentPrerequisiteArgs:
    def __init__(__self__, *,
                 flag_key: pulumi.Input[_builtins.str],
                 variation: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] flag_key: The prerequisite feature flag's `key`.
        :param pulumi.Input[_builtins.int] variation: The index of the prerequisite feature flag's variation to target.
        """
        pulumi.set(__self__, "flag_key", flag_key)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="flagKey")
    def flag_key(self) -> pulumi.Input[_builtins.str]:
        """
        The prerequisite feature flag's `key`.
        """
        return pulumi.get(self, "flag_key")

    @flag_key.setter
    def flag_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flag_key", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the prerequisite feature flag's variation to target.
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagEnvironmentRuleArgsDict(TypedDict):
        bucket_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        """
        clauses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentRuleClauseArgsDict']]]]
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        context_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-readable description of the targeting rule.
        """
        rollout_weights: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        variation: NotRequired[pulumi.Input[_builtins.int]]
        """
        The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
elif False:
    FeatureFlagEnvironmentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentRuleArgs:
    def __init__(__self__, *,
                 bucket_by: Optional[pulumi.Input[_builtins.str]] = None,
                 clauses: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentRuleClauseArgs']]]] = None,
                 context_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_weights: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 variation: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_by: Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        :param pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentRuleClauseArgs']]] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        :param pulumi.Input[_builtins.str] description: A human-readable description of the targeting rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] rollout_weights: List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        :param pulumi.Input[_builtins.int] variation: The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rollout_weights is not None:
            pulumi.set(__self__, "rollout_weights", rollout_weights)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group percentage rollout by a custom attribute. This argument is only valid if `rollout_weights` is also specified.
        """
        return pulumi.get(self, "bucket_by")

    @bucket_by.setter
    def bucket_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_by", value)

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentRuleClauseArgs']]]]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @clauses.setter
    def clauses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentRuleClauseArgs']]]]):
        pulumi.set(self, "clauses", value)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The context kind associated with the specified rollout. This argument is only valid if `rollout_weights` is also specified. Defaults to `user` if omitted.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-readable description of the targeting rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="rolloutWeights")
    def rollout_weights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        List of integer percentage rollout weights (in thousandths of a percent) to apply to each variation if the rule clauses evaluates to `true`. The sum of the `rollout_weights` must equal 100000 and the number of rollout weights specified in the array must match the number of flag variations. You must specify either `variation` or `rollout_weights`.
        """
        return pulumi.get(self, "rollout_weights")

    @rollout_weights.setter
    def rollout_weights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "rollout_weights", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The integer variation index to serve if the rule clauses evaluate to `true`. You must specify either `variation` or `rollout_weights`
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagEnvironmentRuleClauseArgsDict(TypedDict):
        attribute: pulumi.Input[_builtins.str]
        """
        The user attribute to operate on
        """
        op: pulumi.Input[_builtins.str]
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values associated with the rule clause.
        """
        context_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to negate the rule clause.
        """
        value_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
elif False:
    FeatureFlagEnvironmentRuleClauseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentRuleClauseArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input[_builtins.str],
                 op: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 context_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 value_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute: The user attribute to operate on
        :param pulumi.Input[_builtins.str] op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values associated with the rule clause.
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param pulumi.Input[_builtins.bool] negate: Whether to negate the rule clause.
        :param pulumi.Input[_builtins.str] value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> pulumi.Input[_builtins.str]:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> pulumi.Input[_builtins.str]:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class FeatureFlagEnvironmentTargetArgsDict(TypedDict):
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of `user` strings to target.
        """
        variation: pulumi.Input[_builtins.int]
        """
        The index of the variation to serve if a user target value is matched.
        """
elif False:
    FeatureFlagEnvironmentTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentTargetArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 variation: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of `user` strings to target.
        :param pulumi.Input[_builtins.int] variation: The index of the variation to serve if a user target value is matched.
        """
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "variation", variation)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of `user` strings to target.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def variation(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the variation to serve if a user target value is matched.
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagVariationArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        The variation value. The value's type must correspond to the `variation_type` argument. For example: `variation_type = "boolean"` accepts only `true` or `false`. The `number` variation type accepts both floats and ints, but please note that any trailing zeroes on floats will be trimmed (i.e. `1.1` and `1.100` will both be converted to `1.1`).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The feature flag's description.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The human-readable name of the feature flag.
        """
elif False:
    FeatureFlagVariationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagVariationArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The variation value. The value's type must correspond to the `variation_type` argument. For example: `variation_type = "boolean"` accepts only `true` or `false`. The `number` variation type accepts both floats and ints, but please note that any trailing zeroes on floats will be trimmed (i.e. `1.1` and `1.100` will both be converted to `1.1`).
        :param pulumi.Input[_builtins.str] description: The feature flag's description.
        :param pulumi.Input[_builtins.str] name: The human-readable name of the feature flag.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The variation value. The value's type must correspond to the `variation_type` argument. For example: `variation_type = "boolean"` accepts only `true` or `false`. The `number` variation type accepts both floats and ints, but please note that any trailing zeroes on floats will be trimmed (i.e. `1.1` and `1.100` will both be converted to `1.1`).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The feature flag's description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The human-readable name of the feature flag.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FlagTriggerInstructionsArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
elif False:
    FlagTriggerInstructionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlagTriggerInstructionsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] kind: The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        The action to perform when triggering. Currently supported flag actions are `turnFlagOn` and `turnFlagOff`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class MetricUrlArgsDict(TypedDict):
        kind: pulumi.Input[_builtins.str]
        """
        The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        """
        pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Required for kind `regex`) The regex pattern to match by.
        """
        substring: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Required for kind `substring`) The URL substring to match by.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
elif False:
    MetricUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricUrlArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 substring: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        :param pulumi.Input[_builtins.str] pattern: (Required for kind `regex`) The regex pattern to match by.
        :param pulumi.Input[_builtins.str] substring: (Required for kind `substring`) The URL substring to match by.
        :param pulumi.Input[_builtins.str] url: (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        pulumi.set(__self__, "kind", kind)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if substring is not None:
            pulumi.set(__self__, "substring", substring)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        The URL type. Available choices are `exact`, `canonical`, `substring` and `regex`.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required for kind `regex`) The regex pattern to match by.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def substring(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required for kind `substring`) The URL substring to match by.
        """
        return pulumi.get(self, "substring")

    @substring.setter
    def substring(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "substring", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Required for kind `exact` and `canonical`) The exact or canonical URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ProjectDefaultClientSideAvailabilityArgsDict(TypedDict):
        using_environment_id: pulumi.Input[_builtins.bool]
        using_mobile_key: pulumi.Input[_builtins.bool]
elif False:
    ProjectDefaultClientSideAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDefaultClientSideAvailabilityArgs:
    def __init__(__self__, *,
                 using_environment_id: pulumi.Input[_builtins.bool],
                 using_mobile_key: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "using_environment_id", using_environment_id)
        pulumi.set(__self__, "using_mobile_key", using_mobile_key)

    @_builtins.property
    @pulumi.getter(name="usingEnvironmentId")
    def using_environment_id(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "using_environment_id")

    @using_environment_id.setter
    def using_environment_id(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "using_environment_id", value)

    @_builtins.property
    @pulumi.getter(name="usingMobileKey")
    def using_mobile_key(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "using_mobile_key")

    @using_mobile_key.setter
    def using_mobile_key(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "using_mobile_key", value)


if not MYPY:
    class ProjectEnvironmentArgsDict(TypedDict):
        color: pulumi.Input[_builtins.str]
        """
        The color swatch as an RGB hex value with no leading `#`. For example: `000000`
        """
        key: pulumi.Input[_builtins.str]
        """
        The project-unique key for the environment. A change in this field will force the destruction of the existing resource and the creation of a new one.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the environment.
        """
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment's SDK key.
        """
        approval_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentApprovalSettingArgsDict']]]]
        client_side_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment's client-side ID.
        """
        confirm_changes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if this environment requires confirmation for flag and segment changes. This field will default to `false` when not set.
        """
        critical: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Denotes whether the environment is critical.
        """
        default_track_events: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` to enable data export for every flag created in this environment after you configure this argument. This field will default to `false` when not set. To learn more, read [Data Export](https://docs.launchdarkly.com/home/data-export).
        """
        default_ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        The TTL for the environment. This must be between 0 and 60 minutes. The TTL setting only applies to environments using the PHP SDK. This field will default to `0` when not set. To learn more, read [TTL settings](https://docs.launchdarkly.com/home/organize/environments#ttl-settings).
        """
        mobile_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment's mobile key.
        """
        require_comments: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if this environment requires comments for flag and segment changes. This field will default to `false` when not set.
        """
        secure_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` to ensure a user of the client-side SDK cannot impersonate another user. This field will default to `false` when not set.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Tags associated with your resource.
        """
elif False:
    ProjectEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 approval_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentApprovalSettingArgs']]]] = None,
                 client_side_id: Optional[pulumi.Input[_builtins.str]] = None,
                 confirm_changes: Optional[pulumi.Input[_builtins.bool]] = None,
                 critical: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_track_events: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 mobile_key: Optional[pulumi.Input[_builtins.str]] = None,
                 require_comments: Optional[pulumi.Input[_builtins.bool]] = None,
                 secure_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] color: The color swatch as an RGB hex value with no leading `#`. For example: `000000`
        :param pulumi.Input[_builtins.str] key: The project-unique key for the environment. A change in this field will force the destruction of the existing resource and the creation of a new one.
        :param pulumi.Input[_builtins.str] name: The name of the environment.
        :param pulumi.Input[_builtins.str] api_key: The environment's SDK key.
        :param pulumi.Input[_builtins.str] client_side_id: The environment's client-side ID.
        :param pulumi.Input[_builtins.bool] confirm_changes: Set to `true` if this environment requires confirmation for flag and segment changes. This field will default to `false` when not set.
        :param pulumi.Input[_builtins.bool] critical: Denotes whether the environment is critical.
        :param pulumi.Input[_builtins.bool] default_track_events: Set to `true` to enable data export for every flag created in this environment after you configure this argument. This field will default to `false` when not set. To learn more, read [Data Export](https://docs.launchdarkly.com/home/data-export).
        :param pulumi.Input[_builtins.int] default_ttl: The TTL for the environment. This must be between 0 and 60 minutes. The TTL setting only applies to environments using the PHP SDK. This field will default to `0` when not set. To learn more, read [TTL settings](https://docs.launchdarkly.com/home/organize/environments#ttl-settings).
        :param pulumi.Input[_builtins.str] mobile_key: The environment's mobile key.
        :param pulumi.Input[_builtins.bool] require_comments: Set to `true` if this environment requires comments for flag and segment changes. This field will default to `false` when not set.
        :param pulumi.Input[_builtins.bool] secure_mode: Set to `true` to ensure a user of the client-side SDK cannot impersonate another user. This field will default to `false` when not set.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tags associated with your resource.
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if approval_settings is not None:
            pulumi.set(__self__, "approval_settings", approval_settings)
        if client_side_id is not None:
            pulumi.set(__self__, "client_side_id", client_side_id)
        if confirm_changes is not None:
            pulumi.set(__self__, "confirm_changes", confirm_changes)
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if default_track_events is not None:
            pulumi.set(__self__, "default_track_events", default_track_events)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if mobile_key is not None:
            pulumi.set(__self__, "mobile_key", mobile_key)
        if require_comments is not None:
            pulumi.set(__self__, "require_comments", require_comments)
        if secure_mode is not None:
            pulumi.set(__self__, "secure_mode", secure_mode)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def color(self) -> pulumi.Input[_builtins.str]:
        """
        The color swatch as an RGB hex value with no leading `#`. For example: `000000`
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "color", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The project-unique key for the environment. A change in this field will force the destruction of the existing resource and the creation of a new one.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the environment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment's SDK key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="approvalSettings")
    def approval_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentApprovalSettingArgs']]]]:
        return pulumi.get(self, "approval_settings")

    @approval_settings.setter
    def approval_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectEnvironmentApprovalSettingArgs']]]]):
        pulumi.set(self, "approval_settings", value)

    @_builtins.property
    @pulumi.getter(name="clientSideId")
    def client_side_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment's client-side ID.
        """
        return pulumi.get(self, "client_side_id")

    @client_side_id.setter
    def client_side_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_side_id", value)

    @_builtins.property
    @pulumi.getter(name="confirmChanges")
    def confirm_changes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if this environment requires confirmation for flag and segment changes. This field will default to `false` when not set.
        """
        return pulumi.get(self, "confirm_changes")

    @confirm_changes.setter
    def confirm_changes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "confirm_changes", value)

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Denotes whether the environment is critical.
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "critical", value)

    @_builtins.property
    @pulumi.getter(name="defaultTrackEvents")
    def default_track_events(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` to enable data export for every flag created in this environment after you configure this argument. This field will default to `false` when not set. To learn more, read [Data Export](https://docs.launchdarkly.com/home/data-export).
        """
        return pulumi.get(self, "default_track_events")

    @default_track_events.setter
    def default_track_events(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_track_events", value)

    @_builtins.property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The TTL for the environment. This must be between 0 and 60 minutes. The TTL setting only applies to environments using the PHP SDK. This field will default to `0` when not set. To learn more, read [TTL settings](https://docs.launchdarkly.com/home/organize/environments#ttl-settings).
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @_builtins.property
    @pulumi.getter(name="mobileKey")
    def mobile_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment's mobile key.
        """
        return pulumi.get(self, "mobile_key")

    @mobile_key.setter
    def mobile_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mobile_key", value)

    @_builtins.property
    @pulumi.getter(name="requireComments")
    def require_comments(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if this environment requires comments for flag and segment changes. This field will default to `false` when not set.
        """
        return pulumi.get(self, "require_comments")

    @require_comments.setter
    def require_comments(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_comments", value)

    @_builtins.property
    @pulumi.getter(name="secureMode")
    def secure_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` to ensure a user of the client-side SDK cannot impersonate another user. This field will default to `false` when not set.
        """
        return pulumi.get(self, "secure_mode")

    @secure_mode.setter
    def secure_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "secure_mode", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tags associated with your resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ProjectEnvironmentApprovalSettingArgsDict(TypedDict):
        auto_apply_approved_changes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        can_apply_declined_changes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        can_review_own_request: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        min_num_approvals: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        required_approval_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        service_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        service_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
elif False:
    ProjectEnvironmentApprovalSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentApprovalSettingArgs:
    def __init__(__self__, *,
                 auto_apply_approved_changes: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_apply_declined_changes: Optional[pulumi.Input[_builtins.bool]] = None,
                 can_review_own_request: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_num_approvals: Optional[pulumi.Input[_builtins.int]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 required_approval_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 service_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 service_kind: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] auto_apply_approved_changes: Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        :param pulumi.Input[_builtins.bool] can_apply_declined_changes: Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        :param pulumi.Input[_builtins.bool] can_review_own_request: Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        :param pulumi.Input[_builtins.int] min_num_approvals: The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        :param pulumi.Input[_builtins.bool] required: Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] required_approval_tags: An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] service_config: The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:
               
               	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
               	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        :param pulumi.Input[_builtins.str] service_kind: The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        if auto_apply_approved_changes is not None:
            pulumi.set(__self__, "auto_apply_approved_changes", auto_apply_approved_changes)
        if can_apply_declined_changes is not None:
            pulumi.set(__self__, "can_apply_declined_changes", can_apply_declined_changes)
        if can_review_own_request is not None:
            pulumi.set(__self__, "can_review_own_request", can_review_own_request)
        if min_num_approvals is not None:
            pulumi.set(__self__, "min_num_approvals", min_num_approvals)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if required_approval_tags is not None:
            pulumi.set(__self__, "required_approval_tags", required_approval_tags)
        if service_config is not None:
            pulumi.set(__self__, "service_config", service_config)
        if service_kind is not None:
            pulumi.set(__self__, "service_kind", service_kind)

    @_builtins.property
    @pulumi.getter(name="autoApplyApprovedChanges")
    def auto_apply_approved_changes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically apply changes that have been approved by all reviewers. This field is only applicable for approval service kinds other than `launchdarkly`.
        """
        return pulumi.get(self, "auto_apply_approved_changes")

    @auto_apply_approved_changes.setter
    def auto_apply_approved_changes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_apply_approved_changes", value)

    @_builtins.property
    @pulumi.getter(name="canApplyDeclinedChanges")
    def can_apply_declined_changes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if changes can be applied as long as the `min_num_approvals` is met, regardless of whether any reviewers have declined a request. Defaults to `true`.
        """
        return pulumi.get(self, "can_apply_declined_changes")

    @can_apply_declined_changes.setter
    def can_apply_declined_changes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_apply_declined_changes", value)

    @_builtins.property
    @pulumi.getter(name="canReviewOwnRequest")
    def can_review_own_request(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` if requesters can approve or decline their own request. They may always comment. Defaults to `false`.
        """
        return pulumi.get(self, "can_review_own_request")

    @can_review_own_request.setter
    def can_review_own_request(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_review_own_request", value)

    @_builtins.property
    @pulumi.getter(name="minNumApprovals")
    def min_num_approvals(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of approvals required before an approval request can be applied. This number must be between 1 and 5. Defaults to 1.
        """
        return pulumi.get(self, "min_num_approvals")

    @min_num_approvals.setter
    def min_num_approvals(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_num_approvals", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to `true` for changes to flags in this environment to require approval. You may only set `required` to true if `required_approval_tags` is not set and vice versa. Defaults to `false`.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter(name="requiredApprovalTags")
    def required_approval_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of tags used to specify which flags with those tags require approval. You may only set `required_approval_tags` if `required` is set to `false` and vice versa.
        """
        return pulumi.get(self, "required_approval_tags")

    @required_approval_tags.setter
    def required_approval_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "required_approval_tags", value)

    @_builtins.property
    @pulumi.getter(name="serviceConfig")
    def service_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The configuration for the service associated with this approval. This is specific to each approval service. For a `service_kind` of `servicenow`, the following fields apply:

        	 - `template` (String) The sys_id of the Standard Change Request Template in ServiceNow that LaunchDarkly will use when creating the change request.
        	 - `detail_column` (String) The name of the ServiceNow Change Request column LaunchDarkly uses to populate detailed approval request information. This is most commonly "justification".
        """
        return pulumi.get(self, "service_config")

    @service_config.setter
    def service_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "service_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceKind")
    def service_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kind of service associated with this approval. This determines which platform is used for requesting approval. Valid values are `servicenow`, `launchdarkly`. If you use a value other than `launchdarkly`, you must have already configured the integration in the LaunchDarkly UI or your apply will fail.
        """
        return pulumi.get(self, "service_kind")

    @service_kind.setter
    def service_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_kind", value)


if not MYPY:
    class RelayProxyConfigurationPolicyArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    RelayProxyConfigurationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RelayProxyConfigurationPolicyArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class SegmentExcludedContextArgsDict(TypedDict):
        context_kind: pulumi.Input[_builtins.str]
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of target object keys included in or excluded from the segment.
        """
elif False:
    SegmentExcludedContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SegmentExcludedContextArgs:
    def __init__(__self__, *,
                 context_kind: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SegmentIncludedContextArgsDict(TypedDict):
        context_kind: pulumi.Input[_builtins.str]
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of target object keys included in or excluded from the segment.
        """
elif False:
    SegmentIncludedContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SegmentIncludedContextArgs:
    def __init__(__self__, *,
                 context_kind: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: List of target object keys included in or excluded from the segment.
        """
        pulumi.set(__self__, "context_kind", context_kind)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> pulumi.Input[_builtins.str]:
        """
        The context kind associated with this segment target. To target on user contexts, use the included and excluded attributes.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of target object keys included in or excluded from the segment.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SegmentRuleArgsDict(TypedDict):
        bucket_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attribute by which to group contexts together.
        """
        clauses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SegmentRuleClauseArgsDict']]]]
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        rollout_context_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The integer weight of the rule (between 1 and 100000).
        """
elif False:
    SegmentRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SegmentRuleArgs:
    def __init__(__self__, *,
                 bucket_by: Optional[pulumi.Input[_builtins.str]] = None,
                 clauses: Optional[pulumi.Input[Sequence[pulumi.Input['SegmentRuleClauseArgs']]]] = None,
                 rollout_context_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_by: The attribute by which to group contexts together.
        :param pulumi.Input[Sequence[pulumi.Input['SegmentRuleClauseArgs']]] clauses: List of nested blocks specifying the logical clauses to evaluate
        :param pulumi.Input[_builtins.str] rollout_context_kind: The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        :param pulumi.Input[_builtins.int] weight: The integer weight of the rule (between 1 and 100000).
        """
        if bucket_by is not None:
            pulumi.set(__self__, "bucket_by", bucket_by)
        if clauses is not None:
            pulumi.set(__self__, "clauses", clauses)
        if rollout_context_kind is not None:
            pulumi.set(__self__, "rollout_context_kind", rollout_context_kind)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="bucketBy")
    def bucket_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attribute by which to group contexts together.
        """
        return pulumi.get(self, "bucket_by")

    @bucket_by.setter
    def bucket_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_by", value)

    @_builtins.property
    @pulumi.getter
    def clauses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SegmentRuleClauseArgs']]]]:
        """
        List of nested blocks specifying the logical clauses to evaluate
        """
        return pulumi.get(self, "clauses")

    @clauses.setter
    def clauses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SegmentRuleClauseArgs']]]]):
        pulumi.set(self, "clauses", value)

    @_builtins.property
    @pulumi.getter(name="rolloutContextKind")
    def rollout_context_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The context kind associated with this segment rule. This argument is only valid if `weight` is also specified. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "rollout_context_kind")

    @rollout_context_kind.setter
    def rollout_context_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rollout_context_kind", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The integer weight of the rule (between 1 and 100000).
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class SegmentRuleClauseArgsDict(TypedDict):
        attribute: pulumi.Input[_builtins.str]
        """
        The user attribute to operate on
        """
        op: pulumi.Input[_builtins.str]
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values associated with the rule clause.
        """
        context_kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to negate the rule clause.
        """
        value_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
elif False:
    SegmentRuleClauseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SegmentRuleClauseArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input[_builtins.str],
                 op: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 context_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 value_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute: The user attribute to operate on
        :param pulumi.Input[_builtins.str] op: The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values associated with the rule clause.
        :param pulumi.Input[_builtins.str] context_kind: The context kind associated with this rule clause. If omitted, defaults to `user`.
        :param pulumi.Input[_builtins.bool] negate: Whether to negate the rule clause.
        :param pulumi.Input[_builtins.str] value_type: The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if context_kind is not None:
            pulumi.set(__self__, "context_kind", context_kind)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def attribute(self) -> pulumi.Input[_builtins.str]:
        """
        The user attribute to operate on
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> pulumi.Input[_builtins.str]:
        """
        The operator associated with the rule clause. Available options are `in`, `endsWith`, `startsWith`, `matches`, `contains`, `lessThan`, `lessThanOrEqual`, `greaterThanOrEqual`, `before`, `after`, `segmentMatch`, `semVerEqual`, `semVerLessThan`, and `semVerGreaterThan`. Read LaunchDarkly's [Operators](https://docs.launchdarkly.com/sdk/concepts/flag-evaluation-rules#operators) documentation for more information.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values associated with the rule clause.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="contextKind")
    def context_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The context kind associated with this rule clause. If omitted, defaults to `user`.
        """
        return pulumi.get(self, "context_kind")

    @context_kind.setter
    def context_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context_kind", value)

    @_builtins.property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to negate the rule clause.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negate", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type for each of the clause's values. Available types are `boolean`, `string`, and `number`. If omitted, `value_type` defaults to `string`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class TeamMemberRoleAttributeArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
elif False:
    TeamMemberRoleAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamMemberRoleAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TeamRoleAttributeArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
elif False:
    TeamRoleAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamRoleAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class WebhookStatementArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        not_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        not_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
elif False:
    WebhookStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookStatementArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: The list of action specifiers defining the actions to which the statement applies.
               Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_actions: The list of action specifiers defining the actions to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_resources: The list of resource specifiers defining the resources to which the statement does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The list of resource specifiers defining the resources to which the statement applies.
        """
        pulumi.set(__self__, "effect", effect)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if not_actions is not None:
            pulumi.set(__self__, "not_actions", not_actions)
        if not_resources is not None:
            pulumi.set(__self__, "not_resources", not_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Either `allow` or `deny`. This argument defines whether the statement allows or denies access to the named resources and actions.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement applies.
        Either `actions` or `not_actions` must be specified. For a list of available actions read [Actions reference](https://docs.launchdarkly.com/home/account-security/custom-roles/actions#actions-reference).
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="notActions")
    def not_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of action specifiers defining the actions to which the statement does not apply.
        """
        return pulumi.get(self, "not_actions")

    @not_actions.setter
    def not_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_actions", value)

    @_builtins.property
    @pulumi.getter(name="notResources")
    def not_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement does not apply.
        """
        return pulumi.get(self, "not_resources")

    @not_resources.setter
    def not_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_resources", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of resource specifiers defining the resources to which the statement applies.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class GetTeamMemberRoleAttributeArgsDict(TypedDict):
        key: _builtins.str
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
elif False:
    GetTeamMemberRoleAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTeamMemberRoleAttributeArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetTeamRoleAttributeArgsDict(TypedDict):
        key: _builtins.str
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
elif False:
    GetTeamRoleAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTeamRoleAttributeArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        :param Sequence[_builtins.str] values: A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key / name of your role attribute. In the example `$${roleAttribute/testAttribute}`, the key is `testAttribute`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values for your role attribute. For example, if your policy statement defines the resource `"proj/$${roleAttribute/testAttribute}"`, the values would be the keys of the projects you wanted to assign access to.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


