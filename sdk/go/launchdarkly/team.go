// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package launchdarkly

import (
	"context"
	"reflect"

	"errors"
	"github.com/primait/pulumi-launchdarkly/sdk/go/launchdarkly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a LaunchDarkly team resource.
//
// This resource allows you to create and manage a team within your LaunchDarkly organization.
//
// > **Note:** Teams are available to customers on an Enterprise LaunchDarkly plan. To learn more, [read about our pricing](https://launchdarkly.com/pricing/). To upgrade your plan, [contact LaunchDarkly Sales](https://launchdarkly.com/contact-sales/).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/primait/pulumi-launchdarkly/sdk/go/launchdarkly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := launchdarkly.NewTeam(ctx, "platform_team", &launchdarkly.TeamArgs{
//				Key:         pulumi.String("platform_team"),
//				Name:        pulumi.String("Platform team"),
//				Description: pulumi.String("Team to manage internal infrastructure"),
//				MemberIds: pulumi.StringArray{
//					pulumi.String("507f1f77bcf86cd799439011"),
//					pulumi.String("569f183514f4432160000007"),
//				},
//				Maintainers: pulumi.StringArray{
//					pulumi.String("12ab3c45de678910abc12345"),
//				},
//				CustomRoleKeys: pulumi.StringArray{
//					pulumi.String("platform"),
//					pulumi.String("nomad-administrators"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # A LaunchDarkly team can be imported using the team key
//
// ```sh
// $ pulumi import launchdarkly:index/team:Team platform_team platform_team
// ```
type Team struct {
	pulumi.CustomResourceState

	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayOutput `pulumi:"customRoleKeys"`
	// The team description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
	Key pulumi.StringOutput `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayOutput `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayOutput `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name pulumi.StringOutput `pulumi:"name"`
	// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
	RoleAttributes TeamRoleAttributeArrayOutput `pulumi:"roleAttributes"`
}

// NewTeam registers a new resource with the given unique name, arguments, and options.
func NewTeam(ctx *pulumi.Context,
	name string, args *TeamArgs, opts ...pulumi.ResourceOption) (*Team, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Team
	err := ctx.RegisterResource("launchdarkly:index/team:Team", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeam gets an existing Team resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeam(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamState, opts ...pulumi.ResourceOption) (*Team, error) {
	var resource Team
	err := ctx.ReadResource("launchdarkly:index/team:Team", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Team resources.
type teamState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team description.
	Description *string `pulumi:"description"`
	// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
	Key *string `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers []string `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds []string `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name *string `pulumi:"name"`
	// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
	RoleAttributes []TeamRoleAttribute `pulumi:"roleAttributes"`
}

type TeamState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team description.
	Description pulumi.StringPtrInput
	// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
	Key pulumi.StringPtrInput
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayInput
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayInput
	// A human-friendly name for the team.
	Name pulumi.StringPtrInput
	// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
	RoleAttributes TeamRoleAttributeArrayInput
}

func (TeamState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamState)(nil)).Elem()
}

type teamArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team description.
	Description *string `pulumi:"description"`
	// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
	Key string `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers []string `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds []string `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name *string `pulumi:"name"`
	// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
	RoleAttributes []TeamRoleAttribute `pulumi:"roleAttributes"`
}

// The set of arguments for constructing a Team resource.
type TeamArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team description.
	Description pulumi.StringPtrInput
	// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
	Key pulumi.StringInput
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayInput
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayInput
	// A human-friendly name for the team.
	Name pulumi.StringPtrInput
	// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
	RoleAttributes TeamRoleAttributeArrayInput
}

func (TeamArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamArgs)(nil)).Elem()
}

type TeamInput interface {
	pulumi.Input

	ToTeamOutput() TeamOutput
	ToTeamOutputWithContext(ctx context.Context) TeamOutput
}

func (*Team) ElementType() reflect.Type {
	return reflect.TypeOf((**Team)(nil)).Elem()
}

func (i *Team) ToTeamOutput() TeamOutput {
	return i.ToTeamOutputWithContext(context.Background())
}

func (i *Team) ToTeamOutputWithContext(ctx context.Context) TeamOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamOutput)
}

// TeamArrayInput is an input type that accepts TeamArray and TeamArrayOutput values.
// You can construct a concrete instance of `TeamArrayInput` via:
//
//	TeamArray{ TeamArgs{...} }
type TeamArrayInput interface {
	pulumi.Input

	ToTeamArrayOutput() TeamArrayOutput
	ToTeamArrayOutputWithContext(context.Context) TeamArrayOutput
}

type TeamArray []TeamInput

func (TeamArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Team)(nil)).Elem()
}

func (i TeamArray) ToTeamArrayOutput() TeamArrayOutput {
	return i.ToTeamArrayOutputWithContext(context.Background())
}

func (i TeamArray) ToTeamArrayOutputWithContext(ctx context.Context) TeamArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamArrayOutput)
}

// TeamMapInput is an input type that accepts TeamMap and TeamMapOutput values.
// You can construct a concrete instance of `TeamMapInput` via:
//
//	TeamMap{ "key": TeamArgs{...} }
type TeamMapInput interface {
	pulumi.Input

	ToTeamMapOutput() TeamMapOutput
	ToTeamMapOutputWithContext(context.Context) TeamMapOutput
}

type TeamMap map[string]TeamInput

func (TeamMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Team)(nil)).Elem()
}

func (i TeamMap) ToTeamMapOutput() TeamMapOutput {
	return i.ToTeamMapOutputWithContext(context.Background())
}

func (i TeamMap) ToTeamMapOutputWithContext(ctx context.Context) TeamMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMapOutput)
}

type TeamOutput struct{ *pulumi.OutputState }

func (TeamOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Team)(nil)).Elem()
}

func (o TeamOutput) ToTeamOutput() TeamOutput {
	return o
}

func (o TeamOutput) ToTeamOutputWithContext(ctx context.Context) TeamOutput {
	return o
}

// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
func (o TeamOutput) CustomRoleKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.CustomRoleKeys }).(pulumi.StringArrayOutput)
}

// The team description.
func (o TeamOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Team) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The team key. A change in this field will force the destruction of the existing resource and the creation of a new one.
func (o TeamOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *Team) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// List of member IDs for users who maintain the team.
func (o TeamOutput) Maintainers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.Maintainers }).(pulumi.StringArrayOutput)
}

// List of member IDs who belong to the team.
func (o TeamOutput) MemberIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.MemberIds }).(pulumi.StringArrayOutput)
}

// A human-friendly name for the team.
func (o TeamOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Team) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A role attributes block. One block must be defined per role attribute. The key is the role attribute key and the value is a string array of resource keys that apply.
func (o TeamOutput) RoleAttributes() TeamRoleAttributeArrayOutput {
	return o.ApplyT(func(v *Team) TeamRoleAttributeArrayOutput { return v.RoleAttributes }).(TeamRoleAttributeArrayOutput)
}

type TeamArrayOutput struct{ *pulumi.OutputState }

func (TeamArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Team)(nil)).Elem()
}

func (o TeamArrayOutput) ToTeamArrayOutput() TeamArrayOutput {
	return o
}

func (o TeamArrayOutput) ToTeamArrayOutputWithContext(ctx context.Context) TeamArrayOutput {
	return o
}

func (o TeamArrayOutput) Index(i pulumi.IntInput) TeamOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Team {
		return vs[0].([]*Team)[vs[1].(int)]
	}).(TeamOutput)
}

type TeamMapOutput struct{ *pulumi.OutputState }

func (TeamMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Team)(nil)).Elem()
}

func (o TeamMapOutput) ToTeamMapOutput() TeamMapOutput {
	return o
}

func (o TeamMapOutput) ToTeamMapOutputWithContext(ctx context.Context) TeamMapOutput {
	return o
}

func (o TeamMapOutput) MapIndex(k pulumi.StringInput) TeamOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Team {
		return vs[0].(map[string]*Team)[vs[1].(string)]
	}).(TeamOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamInput)(nil)).Elem(), &Team{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamArrayInput)(nil)).Elem(), TeamArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMapInput)(nil)).Elem(), TeamMap{})
	pulumi.RegisterOutputType(TeamOutput{})
	pulumi.RegisterOutputType(TeamArrayOutput{})
	pulumi.RegisterOutputType(TeamMapOutput{})
}
