// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package launchdarkly

import (
	"context"
	"reflect"

	"errors"
	"github.com/primait/pulumi-launchdarkly/sdk/go/launchdarkly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/primait/pulumi-launchdarkly/sdk/go/launchdarkly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := launchdarkly.NewTeamRoleMapping(ctx, "platform_team", &launchdarkly.TeamRoleMappingArgs{
//				TeamKey: pulumi.String("platform_team"),
//				CustomRoleKeys: pulumi.StringArray{
//					pulumi.String("platform"),
//					pulumi.String("nomad-administrators"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// A LaunchDarkly team/role mapping can be imported using the team key:
//
// ```sh
// $ pulumi import launchdarkly:index/teamRoleMapping:TeamRoleMapping platform_team platform_team
// ```
type TeamRoleMapping struct {
	pulumi.CustomResourceState

	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayOutput `pulumi:"customRoleKeys"`
	// The team key.
	TeamKey pulumi.StringOutput `pulumi:"teamKey"`
}

// NewTeamRoleMapping registers a new resource with the given unique name, arguments, and options.
func NewTeamRoleMapping(ctx *pulumi.Context,
	name string, args *TeamRoleMappingArgs, opts ...pulumi.ResourceOption) (*TeamRoleMapping, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CustomRoleKeys == nil {
		return nil, errors.New("invalid value for required argument 'CustomRoleKeys'")
	}
	if args.TeamKey == nil {
		return nil, errors.New("invalid value for required argument 'TeamKey'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TeamRoleMapping
	err := ctx.RegisterResource("launchdarkly:index/teamRoleMapping:TeamRoleMapping", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeamRoleMapping gets an existing TeamRoleMapping resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeamRoleMapping(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamRoleMappingState, opts ...pulumi.ResourceOption) (*TeamRoleMapping, error) {
	var resource TeamRoleMapping
	err := ctx.ReadResource("launchdarkly:index/teamRoleMapping:TeamRoleMapping", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TeamRoleMapping resources.
type teamRoleMappingState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team key.
	TeamKey *string `pulumi:"teamKey"`
}

type TeamRoleMappingState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team key.
	TeamKey pulumi.StringPtrInput
}

func (TeamRoleMappingState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamRoleMappingState)(nil)).Elem()
}

type teamRoleMappingArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team key.
	TeamKey string `pulumi:"teamKey"`
}

// The set of arguments for constructing a TeamRoleMapping resource.
type TeamRoleMappingArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team key.
	TeamKey pulumi.StringInput
}

func (TeamRoleMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamRoleMappingArgs)(nil)).Elem()
}

type TeamRoleMappingInput interface {
	pulumi.Input

	ToTeamRoleMappingOutput() TeamRoleMappingOutput
	ToTeamRoleMappingOutputWithContext(ctx context.Context) TeamRoleMappingOutput
}

func (*TeamRoleMapping) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamRoleMapping)(nil)).Elem()
}

func (i *TeamRoleMapping) ToTeamRoleMappingOutput() TeamRoleMappingOutput {
	return i.ToTeamRoleMappingOutputWithContext(context.Background())
}

func (i *TeamRoleMapping) ToTeamRoleMappingOutputWithContext(ctx context.Context) TeamRoleMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamRoleMappingOutput)
}

// TeamRoleMappingArrayInput is an input type that accepts TeamRoleMappingArray and TeamRoleMappingArrayOutput values.
// You can construct a concrete instance of `TeamRoleMappingArrayInput` via:
//
//	TeamRoleMappingArray{ TeamRoleMappingArgs{...} }
type TeamRoleMappingArrayInput interface {
	pulumi.Input

	ToTeamRoleMappingArrayOutput() TeamRoleMappingArrayOutput
	ToTeamRoleMappingArrayOutputWithContext(context.Context) TeamRoleMappingArrayOutput
}

type TeamRoleMappingArray []TeamRoleMappingInput

func (TeamRoleMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamRoleMapping)(nil)).Elem()
}

func (i TeamRoleMappingArray) ToTeamRoleMappingArrayOutput() TeamRoleMappingArrayOutput {
	return i.ToTeamRoleMappingArrayOutputWithContext(context.Background())
}

func (i TeamRoleMappingArray) ToTeamRoleMappingArrayOutputWithContext(ctx context.Context) TeamRoleMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamRoleMappingArrayOutput)
}

// TeamRoleMappingMapInput is an input type that accepts TeamRoleMappingMap and TeamRoleMappingMapOutput values.
// You can construct a concrete instance of `TeamRoleMappingMapInput` via:
//
//	TeamRoleMappingMap{ "key": TeamRoleMappingArgs{...} }
type TeamRoleMappingMapInput interface {
	pulumi.Input

	ToTeamRoleMappingMapOutput() TeamRoleMappingMapOutput
	ToTeamRoleMappingMapOutputWithContext(context.Context) TeamRoleMappingMapOutput
}

type TeamRoleMappingMap map[string]TeamRoleMappingInput

func (TeamRoleMappingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamRoleMapping)(nil)).Elem()
}

func (i TeamRoleMappingMap) ToTeamRoleMappingMapOutput() TeamRoleMappingMapOutput {
	return i.ToTeamRoleMappingMapOutputWithContext(context.Background())
}

func (i TeamRoleMappingMap) ToTeamRoleMappingMapOutputWithContext(ctx context.Context) TeamRoleMappingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamRoleMappingMapOutput)
}

type TeamRoleMappingOutput struct{ *pulumi.OutputState }

func (TeamRoleMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamRoleMapping)(nil)).Elem()
}

func (o TeamRoleMappingOutput) ToTeamRoleMappingOutput() TeamRoleMappingOutput {
	return o
}

func (o TeamRoleMappingOutput) ToTeamRoleMappingOutputWithContext(ctx context.Context) TeamRoleMappingOutput {
	return o
}

// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
func (o TeamRoleMappingOutput) CustomRoleKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TeamRoleMapping) pulumi.StringArrayOutput { return v.CustomRoleKeys }).(pulumi.StringArrayOutput)
}

// The team key.
func (o TeamRoleMappingOutput) TeamKey() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamRoleMapping) pulumi.StringOutput { return v.TeamKey }).(pulumi.StringOutput)
}

type TeamRoleMappingArrayOutput struct{ *pulumi.OutputState }

func (TeamRoleMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamRoleMapping)(nil)).Elem()
}

func (o TeamRoleMappingArrayOutput) ToTeamRoleMappingArrayOutput() TeamRoleMappingArrayOutput {
	return o
}

func (o TeamRoleMappingArrayOutput) ToTeamRoleMappingArrayOutputWithContext(ctx context.Context) TeamRoleMappingArrayOutput {
	return o
}

func (o TeamRoleMappingArrayOutput) Index(i pulumi.IntInput) TeamRoleMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TeamRoleMapping {
		return vs[0].([]*TeamRoleMapping)[vs[1].(int)]
	}).(TeamRoleMappingOutput)
}

type TeamRoleMappingMapOutput struct{ *pulumi.OutputState }

func (TeamRoleMappingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamRoleMapping)(nil)).Elem()
}

func (o TeamRoleMappingMapOutput) ToTeamRoleMappingMapOutput() TeamRoleMappingMapOutput {
	return o
}

func (o TeamRoleMappingMapOutput) ToTeamRoleMappingMapOutputWithContext(ctx context.Context) TeamRoleMappingMapOutput {
	return o
}

func (o TeamRoleMappingMapOutput) MapIndex(k pulumi.StringInput) TeamRoleMappingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TeamRoleMapping {
		return vs[0].(map[string]*TeamRoleMapping)[vs[1].(string)]
	}).(TeamRoleMappingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamRoleMappingInput)(nil)).Elem(), &TeamRoleMapping{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamRoleMappingArrayInput)(nil)).Elem(), TeamRoleMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamRoleMappingMapInput)(nil)).Elem(), TeamRoleMappingMap{})
	pulumi.RegisterOutputType(TeamRoleMappingOutput{})
	pulumi.RegisterOutputType(TeamRoleMappingArrayOutput{})
	pulumi.RegisterOutputType(TeamRoleMappingMapOutput{})
}
